


local ESP = {
    Enabled = true,
    Players = {},
    Objects = {},
    Connections = {},
    Fonts = {
        ["UI"] = 0,
        ["System"] = 1,
        ["Plex"] = 2,
        ["Monospace"] = 3
    },
    KeybindsConfigured = false,
    Settings = {
        BoxEnabled = true,
        BoxType = "2D",
        BoxColor = Color3.new(1, 1, 1),
        BoxThickness = 1,
        BoxTransparency = 1,
        BoxOutline = true,
        BoxOutlineColor = Color3.new(0, 0, 0),
        BoxOutlineTransparency = 1,
        BoxFilled = false,
        BoxFilledTransparency = 0.5,
        BoxPadding = Vector3.new(0, 0, 0),
        
        NameEnabled = true,
        NameColor = Color3.new(1, 1, 1),
        NameTransparency = 1,
        NameSize = 13,
        NameOutline = true,
        NameOutlineColor = Color3.new(0, 0, 0),
        NameFont = 0,
        NamePosition = "Top",
        NameXOffset = 0,
        NameYOffset = 0,
        
        DistanceEnabled = true,
        DistanceColor = Color3.new(1, 1, 1),
        DistanceTransparency = 1,
        DistanceSize = 13,
        DistanceOutline = true,
        DistanceOutlineColor = Color3.new(0, 0, 0),
        DistanceFont = 0,
        DistancePosition = "Bottom",
        DistanceXOffset = 0,
        DistanceYOffset = 0,
        
        HealthEnabled = true,
        HealthColor = Color3.new(0, 1, 0),
        HealthTransparency = 1,
        HealthSize = 13,
        HealthOutline = true,
        HealthOutlineColor = Color3.new(0, 0, 0),
        HealthFont = 0,
        HealthPosition = "Left",
        HealthXOffset = 0,
        HealthYOffset = 0,
        HealthAutoColor = true,
        HealthBarEnabled = true,
        HealthBarThickness = 1,
        HealthBarTransparency = 1,
        HealthBarOutline = true,
        HealthBarOutlineColor = Color3.new(0, 0, 0),
        HealthBarOutlineTransparency = 1,
        HealthBarFilled = true,
        HealthBarFilledTransparency = 0.5,
        HealthBarPosition = "Bottom",
        HealthBarXOffset = 0,
        HealthBarYOffset = 0,
        HealthBarSide = "Left",
        
        TracerEnabled = true,
        TracerColor = Color3.new(1, 1, 1),
        TracerTransparency = 1,
        TracerThickness = 1,
        TracerOutline = true,
        TracerOutlineColor = Color3.new(0, 0, 0),
        TracerOutlineTransparency = 1,
        TracerOrigin = "Bottom",
        TracerXOffset = 0,
        TracerYOffset = 0,
        TracerStyle = "Line",
        TracerDashSize = 3,
        TracerDashGap = 2,
        
        ChamsEnabled = false,
        ChamsColor = Color3.new(1, 0, 0),
        ChamsTransparency = 0.5,
        ChamsOutlineColor = Color3.new(0, 0, 0),
        ChamsOutlineTransparency = 0,
        ChamsOutlineEnabled = false,
        ChamsDepthMode = "Occluded",
        
        SkeletonEnabled = false,
        SkeletonColor = Color3.new(1, 1, 1),
        SkeletonTransparency = 1,
        SkeletonThickness = 1,
        SkeletonOutline = true,
        SkeletonOutlineColor = Color3.new(0, 0, 0),
        SkeletonOutlineTransparency = 1,
        
        HeadDotEnabled = false,
        HeadDotColor = Color3.new(1, 0, 0),
        HeadDotTransparency = 1,
        HeadDotThickness = 1,
        HeadDotOutline = true,
        HeadDotOutlineColor = Color3.new(0, 0, 0),
        HeadDotOutlineTransparency = 1,
        HeadDotSize = 5,
        HeadDotFilled = true,
        HeadDotFilledTransparency = 0.5,
        
        WeaponEnabled = false,
        WeaponColor = Color3.new(1, 1, 1),
        WeaponTransparency = 1,
        WeaponSize = 13,
        WeaponOutline = true,
        WeaponOutlineColor = Color3.new(0, 0, 0),
        WeaponFont = 0,
        WeaponPosition = "Bottom",
        WeaponXOffset = 0,
        WeaponYOffset = 10,
        
        LightingEnabled = false,
        Brightness = 1,
        Contrast = 1,
        Saturation = 1,
        TintColor = Color3.new(1, 1, 1),
        
        TeamCheck = false,
        TeamColor = false,
        FriendCheck = false,
        
        MaxDistance = 1000,
        MinDistance = 0,
        
        ToggleKey = Enum.KeyCode.F1,
        BoxToggleKey = Enum.KeyCode.F2,
        NameToggleKey = Enum.KeyCode.F3,
        DistanceToggleKey = Enum.KeyCode.F4,
        HealthToggleKey = Enum.KeyCode.F5,
        TracerToggleKey = Enum.KeyCode.F6,
        ChamsToggleKey = Enum.KeyCode.F7,
        SkeletonToggleKey = Enum.KeyCode.F8,
        HeadDotToggleKey = Enum.KeyCode.F9,
        
        ZIndex = 1
    }
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

local Vector2new = Vector2.new
local Vector3new = Vector3.new
local CFramenew = CFrame.new
local Color3new = Color3.new
local Color3fromRGB = Color3.fromRGB
local Drawingnew = Drawing.new
local WorldToViewportPoint = Camera.WorldToViewportPoint
local RaycastParamsnew = RaycastParams.new
local EnumRaycastFilterTypeBlacklist = Enum.RaycastFilterType.Blacklist
local Raycast = workspace.Raycast
local GetPlayers = Players.GetPlayers
local Instancenew = Instance.new
local IsA = game.IsA
local FindFirstChild = game.FindFirstChild
local FindFirstChildWhichIsA = game.FindFirstChildWhichIsA
local IsDescendantOf = game.IsDescendantOf
local GetPlayerFromCharacter = Players.GetPlayerFromCharacter
local GetPartsObscuringTarget = Camera.GetPartsObscuringTarget
local GetMouseLocation = UserInputService.GetMouseLocation
local ViewportSize = Camera.ViewportSize
local tan = math.tan
local rad = math.rad
local floor = math.floor
local round = math.round
local clamp = math.clamp
local atan2 = math.atan2
local abs = math.abs
local min = math.min
local max = math.max
local huge = math.huge
local pi = math.pi
local insert = table.insert
local remove = table.remove
local find = table.find
local clear = table.clear
local create = table.create
local concat = table.concat
local sort = table.sort
local pack = table.pack
local unpack = table.unpack
local tostring = tostring
local tonumber = tonumber
local typeof = typeof
local string_format = string.format
local string_gmatch = string.gmatch
local string_match = string.match
local string_len = string.len
local string_sub = string.sub
local string_split = string.split
local string_char = string.char
local string_byte = string.byte
local string_rep = string.rep
local string_gsub = string.gsub
local string_lower = string.lower
local string_upper = string.upper
local string_reverse = string.reverse
local coroutine_create = coroutine.create
local coroutine_resume = coroutine.resume
local coroutine_yield = coroutine.yield
local coroutine_status = coroutine.status
local coroutine_running = coroutine.running
local coroutine_wrap = coroutine.wrap
local task_spawn = task.spawn
local task_wait = task.wait
local task_delay = task.delay
local task_cancel = task.cancel
local task_defer = task.defer

function ESP:Init()
    self.Connections.RenderStepped = RunService.RenderStepped:Connect(function()
        self:Update()
    end)
    
    self.Connections.PlayerAdded = Players.PlayerAdded:Connect(function(player)
        self:AddPlayer(player)
    end)
    
    self.Connections.PlayerRemoving = Players.PlayerRemoving:Connect(function(player)
        self:RemovePlayer(player)
    end)
    
    for _, player in ipairs(GetPlayers(Players)) do
        self:AddPlayer(player)
    end
    
    self.Connections.InputBegan = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if not self.KeybindsConfigured then return end
        
        if input.KeyCode == self.Settings.ToggleKey then
            self.Enabled = not self.Enabled
            
            if not self.Enabled then
                for _, playerData in pairs(self.Players) do
                    for _, drawing in pairs(playerData.Drawings) do
                        if type(drawing) == "table" then
                            if drawing.Line then
                                drawing.Line.Visible = false
                                drawing.Outline.Visible = false
                            else
                                for _, subDrawing in pairs(drawing) do
                                    if type(subDrawing) == "table" then
                                        subDrawing.Line.Visible = false
                                        subDrawing.Outline.Visible = false
                                    else
                                        subDrawing.Visible = false
                                    end
                                end
                            end
                        else
                            drawing.Visible = false
                        end
                    end
                end
                
                for _, objectData in pairs(self.Objects) do
                    for _, drawing in pairs(objectData.Drawings) do
                        if type(drawing) == "table" then
                            if drawing.Line then
                                drawing.Line.Visible = false
                                drawing.Outline.Visible = false
                            else
                                for _, subDrawing in pairs(drawing) do
                                    if type(subDrawing) == "table" then
                                        subDrawing.Line.Visible = false
                                        subDrawing.Outline.Visible = false
                                    else
                                        subDrawing.Visible = false
                                    end
                                end
                            end
                        else
                            drawing.Visible = false
                        end
                    end
                end
            end
        elseif input.KeyCode == self.Settings.BoxToggleKey then
            self.Settings.BoxEnabled = not self.Settings.BoxEnabled
        elseif input.KeyCode == self.Settings.NameToggleKey then
            self.Settings.NameEnabled = not self.Settings.NameEnabled
        elseif input.KeyCode == self.Settings.DistanceToggleKey then
            self.Settings.DistanceEnabled = not self.Settings.DistanceEnabled
        elseif input.KeyCode == self.Settings.HealthToggleKey then
            self.Settings.HealthEnabled = not self.Settings.HealthEnabled
        elseif input.KeyCode == self.Settings.TracerToggleKey then
            self.Settings.TracerEnabled = not self.Settings.TracerEnabled
        elseif input.KeyCode == self.Settings.ChamsToggleKey then
            self.Settings.ChamsEnabled = not self.Settings.ChamsEnabled
        elseif input.KeyCode == self.Settings.SkeletonToggleKey then
            self.Settings.SkeletonEnabled = not self.Settings.SkeletonEnabled
        elseif input.KeyCode == self.Settings.HeadDotToggleKey then
            self.Settings.HeadDotEnabled = not self.Settings.HeadDotEnabled
        end
    end)
    
    return self
end

function ESP:SetKeybind(action, keyCode)
    if action == "Toggle" then
        self.Settings.ToggleKey = keyCode
    elseif action == "Box" then
        self.Settings.BoxToggleKey = keyCode
    elseif action == "Name" then
        self.Settings.NameToggleKey = keyCode
    elseif action == "Distance" then
        self.Settings.DistanceToggleKey = keyCode
    elseif action == "Health" then
        self.Settings.HealthToggleKey = keyCode
    elseif action == "Tracer" then
        self.Settings.TracerToggleKey = keyCode
    elseif action == "Chams" then
        self.Settings.ChamsToggleKey = keyCode
    elseif action == "Skeleton" then
        self.Settings.SkeletonToggleKey = keyCode
    elseif action == "HeadDot" then
        self.Settings.HeadDotToggleKey = keyCode
    end

    return true
end

function ESP:ConfigureKeybinds(keybinds)
    if type(keybinds) ~= "table" then return false end

    if keybinds.Toggle then
        self.Settings.ToggleKey = keybinds.Toggle
    end

    if keybinds.Box then
        self.Settings.BoxToggleKey = keybinds.Box
    end

    if keybinds.Name then
        self.Settings.NameToggleKey = keybinds.Name
    end

    if keybinds.Distance then
        self.Settings.DistanceToggleKey = keybinds.Distance
    end

    if keybinds.Health then
        self.Settings.HealthToggleKey = keybinds.Health
    end

    if keybinds.Tracer then
        self.Settings.TracerToggleKey = keybinds.Tracer
    end

    if keybinds.Chams then
        self.Settings.ChamsToggleKey = keybinds.Chams
    end

    if keybinds.Skeleton then
        self.Settings.SkeletonToggleKey = keybinds.Skeleton
    end

    if keybinds.HeadDot then
        self.Settings.HeadDotToggleKey = keybinds.HeadDot
    end

    self.KeybindsConfigured = true

    return true
end

function ESP:ResetKeybinds()
    self.Settings.ToggleKey = Enum.KeyCode.RightShift
    self.Settings.BoxToggleKey = Enum.KeyCode.One
    self.Settings.NameToggleKey = Enum.KeyCode.Two
    self.Settings.DistanceToggleKey = Enum.KeyCode.Three
    self.Settings.HealthToggleKey = Enum.KeyCode.Four
    self.Settings.TracerToggleKey = Enum.KeyCode.Five
    self.Settings.ChamsToggleKey = Enum.KeyCode.Six
    self.Settings.SkeletonToggleKey = Enum.KeyCode.Seven
    self.Settings.HeadDotToggleKey = Enum.KeyCode.Eight

    self.KeybindsConfigured = true

    return true
end

function ESP:EnableKeybinds(enabled)
    if enabled ~= nil then
        self.KeybindsConfigured = enabled
    else
        self.KeybindsConfigured = not self.KeybindsConfigured
    end

    return self.KeybindsConfigured
end

function ESP:GetKeybinds()
    return {
        Toggle = self.Settings.ToggleKey,
        Box = self.Settings.BoxToggleKey,
        Name = self.Settings.NameToggleKey,
        Distance = self.Settings.DistanceToggleKey,
        Health = self.Settings.HealthToggleKey,
        Tracer = self.Settings.TracerToggleKey,
        Chams = self.Settings.ChamsToggleKey,
        Skeleton = self.Settings.SkeletonToggleKey,
        HeadDot = self.Settings.HeadDotToggleKey
    }
end

function ESP:Destroy()
    for _, connection in pairs(self.Connections) do
        connection:Disconnect()
    end
    
    for _, playerData in pairs(self.Players) do
        for _, drawing in pairs(playerData.Drawings) do
            self:RemoveDrawing(drawing)
        end
    end
    
    for _, objectData in pairs(self.Objects) do
        for _, drawing in pairs(objectData.Drawings) do
            self:RemoveDrawing(drawing)
        end
    end
    
    clear(self.Players)
    clear(self.Objects)
    clear(self.Connections)
end

function ESP:CreateDrawing(type, properties)
    local drawing = Drawingnew(type)
    
    for property, value in pairs(properties) do
        drawing[property] = value
    end
    
    return drawing
end

function ESP:RemoveDrawing(drawing)
    if type(drawing) == "table" then
        if drawing.Line then
            drawing.Line:Remove()
            drawing.Outline:Remove()
        else
            for _, subDrawing in pairs(drawing) do
                if type(subDrawing) == "table" then
                    subDrawing.Line:Remove()
                    subDrawing.Outline:Remove()
                else
                    subDrawing:Remove()
                end
            end
        end
    else
        drawing:Remove()
    end
end

function ESP:AddPlayer(player)
    if player == LocalPlayer then return end
    
    local playerData = {
        Player = player,
        Character = player.Character,
        Drawings = {
            Box = self:CreateDrawing("Square", {
                Visible = false,
                Color = self.Settings.BoxColor,
                Thickness = self.Settings.BoxThickness,
                Transparency = self.Settings.BoxTransparency,
                Filled = self.Settings.BoxFilled,
                ZIndex = self.Settings.ZIndex
            }),
            BoxOutline = self:CreateDrawing("Square", {
                Visible = false,
                Color = self.Settings.BoxOutlineColor,
                Thickness = self.Settings.BoxThickness + 2,
                Transparency = self.Settings.BoxOutlineTransparency,
                Filled = false,
                ZIndex = self.Settings.ZIndex - 1
            }),
            BoxFill = self:CreateDrawing("Square", {
                Visible = false,
                Color = self.Settings.BoxColor,
                Transparency = self.Settings.BoxFilledTransparency,
                Filled = true,
                ZIndex = self.Settings.ZIndex - 2
            }),
            BoxCorners = {},
            Box3D = {},
            Name = self:CreateDrawing("Text", {
                Visible = false,
                Color = self.Settings.NameColor,
                Transparency = self.Settings.NameTransparency,
                Size = self.Settings.NameSize,
                Center = true,
                Outline = self.Settings.NameOutline,
                OutlineColor = self.Settings.NameOutlineColor,
                Font = self.Settings.NameFont,
                ZIndex = self.Settings.ZIndex
            }),
            Distance = self:CreateDrawing("Text", {
                Visible = false,
                Color = self.Settings.DistanceColor,
                Transparency = self.Settings.DistanceTransparency,
                Size = self.Settings.DistanceSize,
                Center = true,
                Outline = self.Settings.DistanceOutline,
                OutlineColor = self.Settings.DistanceOutlineColor,
                Font = self.Settings.DistanceFont,
                ZIndex = self.Settings.ZIndex
            }),
            Health = self:CreateDrawing("Text", {
                Visible = false,
                Color = self.Settings.HealthColor,
                Transparency = self.Settings.HealthTransparency,
                Size = self.Settings.HealthSize,
                Center = true,
                Outline = self.Settings.HealthOutline,
                OutlineColor = self.Settings.HealthOutlineColor,
                Font = self.Settings.HealthFont,
                ZIndex = self.Settings.ZIndex
            }),
            HealthBar = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.HealthColor,
                Thickness = self.Settings.HealthBarThickness,
                Transparency = self.Settings.HealthBarTransparency,
                ZIndex = self.Settings.ZIndex
            }),
            HealthBarOutline = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.HealthBarOutlineColor,
                Thickness = self.Settings.HealthBarThickness + 2,
                Transparency = self.Settings.HealthBarOutlineTransparency,
                ZIndex = self.Settings.ZIndex - 1
            }),
            HealthBarBackground = self:CreateDrawing("Line", {
                Visible = false,
                Color = Color3new(0.1, 0.1, 0.1),
                Thickness = self.Settings.HealthBarThickness,
                Transparency = self.Settings.HealthBarTransparency,
                ZIndex = self.Settings.ZIndex - 2
            }),
            Tracer = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.TracerColor,
                Thickness = self.Settings.TracerThickness,
                Transparency = self.Settings.TracerTransparency,
                ZIndex = self.Settings.ZIndex
            }),
            TracerOutline = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.TracerOutlineColor,
                Thickness = self.Settings.TracerThickness + 2,
                Transparency = self.Settings.TracerOutlineTransparency,
                ZIndex = self.Settings.ZIndex - 1
            }),
            TracerDashed = {},
            Skeleton = {},
            HeadDot = self:CreateDrawing("Circle", {
                Visible = false,
                Color = self.Settings.HeadDotColor,
                Thickness = self.Settings.HeadDotThickness,
                Transparency = self.Settings.HeadDotTransparency,
                NumSides = 30,
                Filled = self.Settings.HeadDotFilled,
                ZIndex = self.Settings.ZIndex
            }),
            HeadDotOutline = self:CreateDrawing("Circle", {
                Visible = false,
                Color = self.Settings.HeadDotOutlineColor,
                Thickness = self.Settings.HeadDotThickness + 2,
                Transparency = self.Settings.HeadDotOutlineTransparency,
                NumSides = 30,
                Filled = false,
                ZIndex = self.Settings.ZIndex - 1
            }),
            HeadDotFill = self:CreateDrawing("Circle", {
                Visible = false,
                Color = self.Settings.HeadDotColor,
                Transparency = self.Settings.HeadDotFilledTransparency,
                NumSides = 30,
                Filled = true,
                ZIndex = self.Settings.ZIndex - 2
            }),
            Weapon = self:CreateDrawing("Text", {
                Visible = false,
                Color = self.Settings.WeaponColor,
                Transparency = self.Settings.WeaponTransparency,
                Size = self.Settings.WeaponSize,
                Center = true,
                Outline = self.Settings.WeaponOutline,
                OutlineColor = self.Settings.NameOutlineColor,
                Font = self.Settings.WeaponFont,
                ZIndex = self.Settings.ZIndex
            }),
            Chams = {
                Highlight = Instancenew("Highlight"),
                Enabled = false
            }
        }
    }
    
    for i = 1, 8 do
        playerData.Drawings.BoxCorners[i] = {
            Line = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.BoxColor,
                Thickness = self.Settings.BoxThickness,
                Transparency = self.Settings.BoxTransparency,
                ZIndex = self.Settings.ZIndex
            }),
            Outline = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.BoxOutlineColor,
                Thickness = self.Settings.BoxThickness + 2,
                Transparency = self.Settings.BoxOutlineTransparency,
                ZIndex = self.Settings.ZIndex - 1
            })
        }
    end
    
    for i = 1, 12 do
        playerData.Drawings.Box3D[i] = {
            Line = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.BoxColor,
                Thickness = self.Settings.BoxThickness,
                Transparency = self.Settings.BoxTransparency,
                ZIndex = self.Settings.ZIndex
            }),
            Outline = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.BoxOutlineColor,
                Thickness = self.Settings.BoxThickness + 2,
                Transparency = self.Settings.BoxOutlineTransparency,
                ZIndex = self.Settings.ZIndex - 1
            })
        }
    end
    
    local skeletonConnections = {
        {"Head", "UpperTorso"},
        {"UpperTorso", "LowerTorso"},
        {"UpperTorso", "LeftUpperArm"},
        {"LeftUpperArm", "LeftLowerArm"},
        {"LeftLowerArm", "LeftHand"},
        {"UpperTorso", "RightUpperArm"},
        {"RightUpperArm", "RightLowerArm"},
        {"RightLowerArm", "RightHand"},
        {"LowerTorso", "LeftUpperLeg"},
        {"LeftUpperLeg", "LeftLowerLeg"},
        {"LeftLowerLeg", "LeftFoot"},
        {"LowerTorso", "RightUpperLeg"},
        {"RightUpperLeg", "RightLowerLeg"},
        {"RightLowerLeg", "RightFoot"}
    }
    
    for i, connection in ipairs(skeletonConnections) do
        playerData.Drawings.Skeleton[i] = {
            Line = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.SkeletonColor,
                Thickness = self.Settings.SkeletonThickness,
                Transparency = self.Settings.SkeletonTransparency,
                ZIndex = self.Settings.ZIndex
            }),
            Outline = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.SkeletonOutlineColor,
                Thickness = self.Settings.SkeletonThickness + 2,
                Transparency = self.Settings.SkeletonOutlineTransparency,
                ZIndex = self.Settings.ZIndex - 1
            })
        }
    end
    
    playerData.Drawings.Chams.Highlight.Parent = game.CoreGui
    
    self.Players[player.Name] = playerData
    
    player.CharacterAdded:Connect(function(character)
        playerData.Character = character
    end)
end

function ESP:RemovePlayer(player)
    local playerData = self.Players[player.Name]
    
    if playerData then
        for _, drawing in pairs(playerData.Drawings) do
            self:RemoveDrawing(drawing)
        end
        
        if playerData.Drawings.Chams.Highlight then
            playerData.Drawings.Chams.Highlight:Destroy()
        end
        
        self.Players[player.Name] = nil
    end
end

function ESP:GetTeam(player)
    return player.Team
end

function ESP:IsTeammate(player)
    if self.Settings.TeamCheck then
        return self:GetTeam(player) == self:GetTeam(LocalPlayer)
    end
    
    return false
end

function ESP:IsFriend(player)
    if self.Settings.FriendCheck then
        return player:IsFriendsWith(LocalPlayer.UserId)
    end
    
    return false
end

function ESP:GetCharacter(player)
    return player.Character
end

function ESP:GetHealth(player)
    local character = self:GetCharacter(player)
    if not character then return 0, 0 end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return 0, 0 end
    
    return humanoid.Health, humanoid.MaxHealth
end

function ESP:GetWeapon(player)
    return "Unknown"
end

function ESP:GetBoxCorners(object)
    local character
    local hrp
    local head
    
    if typeof(object) == "Instance" then
        if object:IsA("Player") then
            character = self:GetCharacter(object)
            if not character then return end
            
            hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            
            head = character:FindFirstChild("Head")
            if not head then return end
        elseif object:IsA("Model") then
            character = object
            hrp = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("PrimaryPart") or character:FindFirstChildWhichIsA("BasePart")
            if not hrp then return end
            
            head = character:FindFirstChild("Head") or character:FindFirstChildWhichIsA("BasePart")
            if not head then return end
        elseif object:IsA("BasePart") then
            hrp = object
            head = object
        else
            return
        end
    else
        return
    end
    
    local rootPos = hrp.Position
    local headPos = head.Position
    
    local padding = self.Settings.BoxPadding
    local size = Vector3new(4 + padding.X, headPos.Y - rootPos.Y + 2 + padding.Y, 4 + padding.Z)
    local position = rootPos + Vector3new(0, size.Y / 2 - 0.5, 0)
    
    local cf = CFramenew(position, position + Camera.CFrame.LookVector)
    local tlb = cf * CFramenew(-size.X / 2, size.Y / 2, -size.Z / 2).Position
    local trb = cf * CFramenew(size.X / 2, size.Y / 2, -size.Z / 2).Position
    local blb = cf * CFramenew(-size.X / 2, -size.Y / 2, -size.Z / 2).Position
    local brb = cf * CFramenew(size.X / 2, -size.Y / 2, -size.Z / 2).Position
    local tlf = cf * CFramenew(-size.X / 2, size.Y / 2, size.Z / 2).Position
    local trf = cf * CFramenew(size.X / 2, size.Y / 2, size.Z / 2).Position
    local blf = cf * CFramenew(-size.X / 2, -size.Y / 2, size.Z / 2).Position
    local brf = cf * CFramenew(size.X / 2, -size.Y / 2, size.Z / 2).Position
    
    local tlbs, tlbv = WorldToViewportPoint(Camera, tlb)
    local trbs, trbv = WorldToViewportPoint(Camera, trb)
    local blbs, blbv = WorldToViewportPoint(Camera, blb)
    local brbs, brbv = WorldToViewportPoint(Camera, brb)
    local tlfs, tlfv = WorldToViewportPoint(Camera, tlf)
    local trfs, trfv = WorldToViewportPoint(Camera, trf)
    local blfs, blfv = WorldToViewportPoint(Camera, blf)
    local brfs, brfv = WorldToViewportPoint(Camera, brf)
    
    if not (tlbs or trbs or blbs or brbs or tlfs or trfs or blfs or brfs) then
        return
    end
    
    local minX = min(tlfv.X, trfv.X, blfv.X, brfv.X, tlbv.X, trbv.X, blbv.X, brbv.X)
    local minY = min(tlfv.Y, trfv.Y, blfv.Y, brfv.Y, tlbv.Y, trbv.Y, blbv.Y, brbv.Y)
    local maxX = max(tlfv.X, trfv.X, blfv.X, brfv.X, tlbv.X, trbv.X, blbv.X, brbv.X)
    local maxY = max(tlfv.Y, trfv.Y, blfv.Y, brfv.Y, tlbv.Y, trbv.Y, blbv.Y, brbv.Y)
    
    return {
        TopLeft = Vector2new(minX, minY),
        TopRight = Vector2new(maxX, minY),
        BottomLeft = Vector2new(minX, maxY),
        BottomRight = Vector2new(maxX, maxY),
        Visible = true
    }
end

function ESP:GetCornerBoxPoints(boxCorners)
    if not boxCorners then return end
    
    local topLeft = boxCorners.TopLeft
    local topRight = boxCorners.TopRight
    local bottomLeft = boxCorners.BottomLeft
    local bottomRight = boxCorners.BottomRight
    
    local width = (topRight - topLeft).Magnitude
    local height = (bottomLeft - topLeft).Magnitude
    local cornerSize = min(width, height) * 0.2
    
    local points = {
        {topLeft, topLeft + Vector2new(cornerSize, 0)},
        {topLeft, topLeft + Vector2new(0, cornerSize)},
        {topRight, topRight + Vector2new(-cornerSize, 0)},
        {topRight, topRight + Vector2new(0, cornerSize)},
        {bottomLeft, bottomLeft + Vector2new(cornerSize, 0)},
        {bottomLeft, bottomLeft + Vector2new(0, -cornerSize)},
        {bottomRight, bottomRight + Vector2new(-cornerSize, 0)},
        {bottomRight, bottomRight + Vector2new(0, -cornerSize)}
    }
    
    return points
end

function ESP:Get3DBoxCorners(object)
    local character
    local hrp
    local head
    
    if typeof(object) == "Instance" then
        if object:IsA("Player") then
            character = self:GetCharacter(object)
            if not character then return end
            
            hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            
            head = character:FindFirstChild("Head")
            if not head then return end
        elseif object:IsA("Model") then
            character = object
            hrp = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("PrimaryPart") or character:FindFirstChildWhichIsA("BasePart")
            if not hrp then return end
            
            head = character:FindFirstChild("Head") or character:FindFirstChildWhichIsA("BasePart")
            if not head then return end
        elseif object:IsA("BasePart") then
            hrp = object
            head = object
        else
            return
        end
    else
        return
    end
    
    local rootPos = hrp.Position
    local headPos = head.Position
    
    local padding = self.Settings.BoxPadding
    local size = Vector3new(4 + padding.X, headPos.Y - rootPos.Y + 2 + padding.Y, 4 + padding.Z)
    local position = rootPos + Vector3new(0, size.Y / 2 - 0.5, 0)
    
    local cf = CFramenew(position, position + Camera.CFrame.LookVector)
    local corners = {
        cf * CFramenew(-size.X / 2, size.Y / 2, -size.Z / 2).Position,
        cf * CFramenew(size.X / 2, size.Y / 2, -size.Z / 2).Position,
        cf * CFramenew(-size.X / 2, -size.Y / 2, -size.Z / 2).Position,
        cf * CFramenew(size.X / 2, -size.Y / 2, -size.Z / 2).Position,
        cf * CFramenew(-size.X / 2, size.Y / 2, size.Z / 2).Position,
        cf * CFramenew(size.X / 2, size.Y / 2, size.Z / 2).Position,
        cf * CFramenew(-size.X / 2, -size.Y / 2, size.Z / 2).Position,
        cf * CFramenew(size.X / 2, -size.Y / 2, size.Z / 2).Position
    }
    
    local viewportCorners = {}
    local anyVisible = false
    
    for i, corner in ipairs(corners) do
        local success, position = WorldToViewportPoint(Camera, corner)
        viewportCorners[i] = position
        anyVisible = anyVisible or success
    end
    
    if not anyVisible then
        return
    end
    
    return viewportCorners
end

function ESP:WorldToScreen(position)
    local screenPosition, onScreen = WorldToViewportPoint(Camera, position)
    return Vector2new(screenPosition.X, screenPosition.Y), onScreen, screenPosition.Z
end

function ESP:GetDistance(position)
    return (position - Camera.CFrame.Position).Magnitude
end

function ESP:GetDistanceText(distance)
    if distance < 1000 then
        return string_format("%.1f m", distance)
    else
        return string_format("%.1f km", distance / 1000)
    end
end

function ESP:CalculateTransparency(distance)
    local minDistance = self.Settings.MinDistance
    local maxDistance = self.Settings.MaxDistance
    
    if distance <= minDistance then
        return 1
    elseif distance >= maxDistance then
        return 0
    else
        return 1 - (distance - minDistance) / (maxDistance - minDistance)
    end
end

function ESP:CalculateTextSize(distance)
    local minSize = 8
    local maxSize = 16
    local minDistance = 0
    local maxDistance = 100
    
    if distance <= minDistance then
        return maxSize
    elseif distance >= maxDistance then
        return minSize
    else
        return minSize + (maxSize - minSize) * (1 - (distance - minDistance) / (maxDistance - minDistance))
    end
end

function ESP:CalculatePosition(position, boxCorners, screenPos, xOffset, yOffset)
    if not boxCorners then
        return screenPos + Vector2new(xOffset, yOffset)
    end
    
    local topLeft = boxCorners.TopLeft
    local topRight = boxCorners.TopRight
    local bottomLeft = boxCorners.BottomLeft
    local bottomRight = boxCorners.BottomRight
    
    if position == "Top" then
        return Vector2new((topLeft.X + topRight.X) / 2 + xOffset, topLeft.Y + yOffset)
    elseif position == "Bottom" then
        return Vector2new((bottomLeft.X + bottomRight.X) / 2 + xOffset, bottomLeft.Y + yOffset)
    elseif position == "Left" then
        return Vector2new(topLeft.X + xOffset, (topLeft.Y + bottomLeft.Y) / 2 + yOffset)
    elseif position == "Right" then
        return Vector2new(topRight.X + xOffset, (topRight.Y + bottomRight.Y) / 2 + yOffset)
    elseif position == "TopLeft" then
        return Vector2new(topLeft.X + xOffset, topLeft.Y + yOffset)
    elseif position == "TopRight" then
        return Vector2new(topRight.X + xOffset, topRight.Y + yOffset)
    elseif position == "BottomLeft" then
        return Vector2new(bottomLeft.X + xOffset, bottomLeft.Y + yOffset)
    elseif position == "BottomRight" then
        return Vector2new(bottomRight.X + xOffset, bottomRight.Y + yOffset)
    end
end

function ESP:DrawDashedLine(from, to, dashSize, gapSize, color, thickness, transparency, zIndex)
    local lines = {}
    local direction = (to - from).Unit
    local distance = (to - from).Magnitude
    local step = dashSize + gapSize
    local steps = floor(distance / step)
    
    for i = 0, steps do
        local start = from + direction * (i * step)
        local endPos = start + direction * dashSize
        
        if (endPos - from).Magnitude > distance then
            endPos = to
        end
        
        local line = self:CreateDrawing("Line", {
            Visible = true,
            Color = color,
            Thickness = thickness,
            Transparency = transparency,
            From = start,
            To = endPos,
            ZIndex = zIndex
        })
        
        insert(lines, line)
    end
    
    return lines
end

function ESP:IsVisible(position)
    local character = LocalPlayer.Character
    if not character then return false end
    
    local head = character:FindFirstChild("Head")
    if not head then return false end
    
    local params = RaycastParamsnew()
    params.FilterType = EnumRaycastFilterTypeBlacklist
    params.FilterDescendantsInstances = {character}
    
    local direction = (position - head.Position).Unit
    local result = Raycast(workspace, head.Position, direction * 9999, params)
    
    if result then
        return (result.Position - position).Magnitude < 5
    end
    
    return false
end

function ESP:UpdatePlayer(player)
    local playerData = self.Players[player.Name]
    if not playerData then return end
    
    local character = self:GetCharacter(player)
    if not character then
        for _, drawing in pairs(playerData.Drawings) do
            if type(drawing) == "table" then
                if drawing.Line then
                    drawing.Line.Visible = false
                    drawing.Outline.Visible = false
                else
                    for _, subDrawing in pairs(drawing) do
                        if type(subDrawing) == "table" then
                            subDrawing.Line.Visible = false
                            subDrawing.Outline.Visible = false
                        else
                            subDrawing.Visible = false
                        end
                    end
                end
            else
                drawing.Visible = false
            end
        end
        
        if playerData.Drawings.Chams.Highlight then
            playerData.Drawings.Chams.Highlight.Enabled = false
        end
        
        return
    end
    
    if not self.Enabled then
        for _, drawing in pairs(playerData.Drawings) do
            if type(drawing) == "table" then
                if drawing.Line then
                    drawing.Line.Visible = false
                    drawing.Outline.Visible = false
                else
                    for _, subDrawing in pairs(drawing) do
                        if type(subDrawing) == "table" then
                            subDrawing.Line.Visible = false
                            subDrawing.Outline.Visible = false
                        else
                            subDrawing.Visible = false
                        end
                    end
                end
            else
                drawing.Visible = false
            end
        end
        
        if playerData.Drawings.Chams.Highlight then
            playerData.Drawings.Chams.Highlight.Enabled = false
        end
        
        return
    end
    
    local head = character:FindFirstChild("Head")
    if not head then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local distance = self:GetDistance(hrp.Position)
    if distance > self.Settings.MaxDistance or distance < self.Settings.MinDistance then
        for _, drawing in pairs(playerData.Drawings) do
            if type(drawing) == "table" then
                if drawing.Line then
                    drawing.Line.Visible = false
                    drawing.Outline.Visible = false
                else
                    for _, subDrawing in pairs(drawing) do
                        if type(subDrawing) == "table" then
                            subDrawing.Line.Visible = false
                            subDrawing.Outline.Visible = false
                        else
                            subDrawing.Visible = false
                        end
                    end
                end
            else
                drawing.Visible = false
            end
        end
        
        if playerData.Drawings.Chams.Highlight then
            playerData.Drawings.Chams.Highlight.Enabled = false
        end
        
        return
    end
    
    local transparency = self:CalculateTransparency(distance)
    local isTeammate = self:IsTeammate(player)
    local isFriend = self:IsFriend(player)
    
    if (isTeammate or isFriend) and self.Settings.TeamCheck then
        for _, drawing in pairs(playerData.Drawings) do
            if type(drawing) == "table" then
                if drawing.Line then
                    drawing.Line.Visible = false
                    drawing.Outline.Visible = false
                else
                    for _, subDrawing in pairs(drawing) do
                        if type(subDrawing) == "table" then
                            subDrawing.Line.Visible = false
                            subDrawing.Outline.Visible = false
                        else
                            subDrawing.Visible = false
                        end
                    end
                end
            else
                drawing.Visible = false
            end
        end
        
        if playerData.Drawings.Chams.Highlight then
            playerData.Drawings.Chams.Highlight.Enabled = false
        end
        
        return
    end
    
    local boxCorners = self:GetBoxCorners(player)
    
    if self.Settings.BoxEnabled then
        playerData.Drawings.Box.Visible = false
        playerData.Drawings.BoxOutline.Visible = false
        playerData.Drawings.BoxFill.Visible = false
        
        for _, corner in pairs(playerData.Drawings.BoxCorners) do
            corner.Line.Visible = false
            corner.Outline.Visible = false
        end
        
        for _, line in pairs(playerData.Drawings.Box3D) do
            line.Line.Visible = false
            line.Outline.Visible = false
        end
        
        if boxCorners then
            local topLeft = boxCorners.TopLeft
            local bottomRight = boxCorners.BottomRight
            local boxSize = bottomRight - topLeft
            
            if self.Settings.BoxType == "2D" then
                playerData.Drawings.Box.Position = topLeft
                playerData.Drawings.Box.Size = boxSize
                playerData.Drawings.Box.Color = self.Settings.TeamColor and player.TeamColor.Color or self.Settings.BoxColor
                playerData.Drawings.Box.Transparency = transparency * self.Settings.BoxTransparency
                playerData.Drawings.Box.Visible = true
                
                if self.Settings.BoxOutline then
                    playerData.Drawings.BoxOutline.Position = topLeft
                    playerData.Drawings.BoxOutline.Size = boxSize
                    playerData.Drawings.BoxOutline.Transparency = transparency * self.Settings.BoxOutlineTransparency
                    playerData.Drawings.BoxOutline.Visible = true
                end
                
                if self.Settings.BoxFilled then
                    playerData.Drawings.BoxFill.Position = topLeft
                    playerData.Drawings.BoxFill.Size = boxSize
                    playerData.Drawings.BoxFill.Color = self.Settings.TeamColor and player.TeamColor.Color or self.Settings.BoxColor
                    playerData.Drawings.BoxFill.Transparency = transparency * self.Settings.BoxFilledTransparency
                    playerData.Drawings.BoxFill.Visible = true
                end
            elseif self.Settings.BoxType == "Corner" then
                local cornerPoints = self:GetCornerBoxPoints(boxCorners)
                
                if cornerPoints then
                    for i, points in ipairs(cornerPoints) do
                        if i <= #playerData.Drawings.BoxCorners then
                            playerData.Drawings.BoxCorners[i].Line.From = points[1]
                            playerData.Drawings.BoxCorners[i].Line.To = points[2]
                            playerData.Drawings.BoxCorners[i].Line.Color = self.Settings.TeamColor and player.TeamColor.Color or self.Settings.BoxColor
                            playerData.Drawings.BoxCorners[i].Line.Transparency = transparency * self.Settings.BoxTransparency
                            playerData.Drawings.BoxCorners[i].Line.Visible = true
                            
                            if self.Settings.BoxOutline then
                                playerData.Drawings.BoxCorners[i].Outline.From = points[1]
                                playerData.Drawings.BoxCorners[i].Outline.To = points[2]
                                playerData.Drawings.BoxCorners[i].Outline.Transparency = transparency * self.Settings.BoxOutlineTransparency
                                playerData.Drawings.BoxCorners[i].Outline.Visible = true
                            end
                        end
                    end
                end
            elseif self.Settings.BoxType == "3D" then
                local corners3D = self:Get3DBoxCorners(player)
                
                if corners3D then
                    local edges = {
                        {1, 2}, {2, 4}, {4, 3}, {3, 1},
                        {5, 6}, {6, 8}, {8, 7}, {7, 5},
                        {1, 5}, {2, 6}, {3, 7}, {4, 8}
                    }
                    
                    for i, edge in ipairs(edges) do
                        if i <= #playerData.Drawings.Box3D then
                            playerData.Drawings.Box3D[i].Line.From = Vector2new(corners3D[edge[1]].X, corners3D[edge[1]].Y)
                            playerData.Drawings.Box3D[i].Line.To = Vector2new(corners3D[edge[2]].X, corners3D[edge[2]].Y)
                            playerData.Drawings.Box3D[i].Line.Color = self.Settings.TeamColor and player.TeamColor.Color or self.Settings.BoxColor
                            playerData.Drawings.Box3D[i].Line.Transparency = transparency * self.Settings.BoxTransparency
                            playerData.Drawings.Box3D[i].Line.Visible = true
                            
                            if self.Settings.BoxOutline then
                                playerData.Drawings.Box3D[i].Outline.From = Vector2new(corners3D[edge[1]].X, corners3D[edge[1]].Y)
                                playerData.Drawings.Box3D[i].Outline.To = Vector2new(corners3D[edge[2]].X, corners3D[edge[2]].Y)
                                playerData.Drawings.Box3D[i].Outline.Transparency = transparency * self.Settings.BoxOutlineTransparency
                                playerData.Drawings.Box3D[i].Outline.Visible = true
                            end
                        end
                    end
                end
            end
        end
    else
        playerData.Drawings.Box.Visible = false
        playerData.Drawings.BoxOutline.Visible = false
        playerData.Drawings.BoxFill.Visible = false
        
        for _, corner in pairs(playerData.Drawings.BoxCorners) do
            corner.Line.Visible = false
            corner.Outline.Visible = false
        end
        
        for _, line in pairs(playerData.Drawings.Box3D) do
            line.Line.Visible = false
            line.Outline.Visible = false
        end
    end
    
    if self.Settings.NameEnabled then
        local screenPos, onScreen = self:WorldToScreen(head.Position)
        
        if onScreen then
            local displayName = player.DisplayName
            if displayName ~= player.Name then
                displayName = displayName .. " (" .. player.Name .. ")"
            end
            
            local textSize = self:CalculateTextSize(distance)
            local namePosition = self:CalculatePosition(
                self.Settings.NamePosition, 
                boxCorners, 
                screenPos, 
                self.Settings.NameXOffset, 
                self.Settings.NameYOffset
            )
            
            playerData.Drawings.Name.Position = namePosition
            playerData.Drawings.Name.Text = displayName
            playerData.Drawings.Name.Color = self.Settings.TeamColor and player.TeamColor.Color or self.Settings.NameColor
            playerData.Drawings.Name.Transparency = transparency * self.Settings.NameTransparency
            playerData.Drawings.Name.Size = textSize
            playerData.Drawings.Name.Visible = true
        else
            playerData.Drawings.Name.Visible = false
        end
    else
        playerData.Drawings.Name.Visible = false
    end
    
    if self.Settings.DistanceEnabled then
        local screenPos, onScreen = self:WorldToScreen(head.Position)
        
        if onScreen then
            local distanceText = self:GetDistanceText(distance)
            local textSize = self:CalculateTextSize(distance)
            local distancePosition = self:CalculatePosition(
                self.Settings.DistancePosition, 
                boxCorners, 
                screenPos, 
                self.Settings.DistanceXOffset, 
                self.Settings.DistanceYOffset
            )
            
            playerData.Drawings.Distance.Position = distancePosition
            playerData.Drawings.Distance.Text = distanceText
            playerData.Drawings.Distance.Color = self.Settings.TeamColor and player.TeamColor.Color or self.Settings.DistanceColor
            playerData.Drawings.Distance.Transparency = transparency * self.Settings.DistanceTransparency
            playerData.Drawings.Distance.Size = textSize
            playerData.Drawings.Distance.Visible = true
        else
            playerData.Drawings.Distance.Visible = false
        end
    else
        playerData.Drawings.Distance.Visible = false
    end
    
    if self.Settings.HealthEnabled then
        local screenPos, onScreen = self:WorldToScreen(head.Position)
        
        if onScreen then
            local health, maxHealth = self:GetHealth(player)
            local healthText = string_format("%.0f HP", health)
            local textSize = self:CalculateTextSize(distance)
            local healthPosition = self:CalculatePosition(
                self.Settings.HealthPosition, 
                boxCorners, 
                screenPos, 
                self.Settings.HealthXOffset, 
                self.Settings.HealthYOffset
            )
            
            local healthColor = self.Settings.HealthColor
            if self.Settings.HealthAutoColor then
                local healthPercent = health / maxHealth
                healthColor = Color3new(1 - healthPercent, healthPercent, 0)
            end
            
            playerData.Drawings.Health.Position = healthPosition
            playerData.Drawings.Health.Text = healthText
            playerData.Drawings.Health.Color = healthColor
            playerData.Drawings.Health.Transparency = transparency * self.Settings.HealthTransparency
            playerData.Drawings.Health.Size = textSize
            playerData.Drawings.Health.Visible = true
            
            if self.Settings.HealthBarEnabled and boxCorners then
                local topLeft = boxCorners.TopLeft
                local bottomLeft = boxCorners.BottomLeft
                local topRight = boxCorners.TopRight
                local bottomRight = boxCorners.BottomRight
                
                local healthPercent = health / maxHealth
                local barHeight = (bottomLeft - topLeft).Magnitude
                local barWidth = (topRight - topLeft).Magnitude
                
                local from, to
                
                if self.Settings.HealthBarPosition == "Left" then
                    from = Vector2new(topLeft.X - 5, bottomLeft.Y)
                    to = Vector2new(topLeft.X - 5, topLeft.Y + (1 - healthPercent) * barHeight)
                elseif self.Settings.HealthBarPosition == "Right" then
                    from = Vector2new(topRight.X + 5, bottomRight.Y)
                    to = Vector2new(topRight.X + 5, topRight.Y + (1 - healthPercent) * barHeight)
                elseif self.Settings.HealthBarPosition == "Top" then
                    from = Vector2new(topLeft.X, topLeft.Y - 5)
                    to = Vector2new(topLeft.X + healthPercent * barWidth, topLeft.Y - 5)
                elseif self.Settings.HealthBarPosition == "Bottom" then
                    from = Vector2new(bottomLeft.X, bottomLeft.Y + 5)
                    to = Vector2new(bottomLeft.X + healthPercent * barWidth, bottomLeft.Y + 5)
                end
                
                local healthBarColor = healthColor
                if self.Settings.HealthAutoColor then
                    healthBarColor = Color3new(1 - healthPercent, healthPercent, 0)
                end
                
                playerData.Drawings.HealthBar.From = from
                playerData.Drawings.HealthBar.To = to
                playerData.Drawings.HealthBar.Color = healthBarColor
                playerData.Drawings.HealthBar.Transparency = transparency * self.Settings.HealthBarTransparency
                playerData.Drawings.HealthBar.Visible = true
                
                if self.Settings.HealthBarOutline then
                    playerData.Drawings.HealthBarOutline.From = from
                    playerData.Drawings.HealthBarOutline.To = to
                    playerData.Drawings.HealthBarOutline.Transparency = transparency * self.Settings.HealthBarOutlineTransparency
                    playerData.Drawings.HealthBarOutline.Visible = true
                else
                    playerData.Drawings.HealthBarOutline.Visible = false
                end
                
                if self.Settings.HealthBarPosition == "Left" then
                    playerData.Drawings.HealthBarBackground.From = Vector2new(topLeft.X - 5, topLeft.Y)
                    playerData.Drawings.HealthBarBackground.To = Vector2new(topLeft.X - 5, bottomLeft.Y)
                elseif self.Settings.HealthBarPosition == "Right" then
                    playerData.Drawings.HealthBarBackground.From = Vector2new(topRight.X + 5, topRight.Y)
                    playerData.Drawings.HealthBarBackground.To = Vector2new(topRight.X + 5, bottomRight.Y)
                elseif self.Settings.HealthBarPosition == "Top" then
                    playerData.Drawings.HealthBarBackground.From = Vector2new(topLeft.X, topLeft.Y - 5)
                    playerData.Drawings.HealthBarBackground.To = Vector2new(topRight.X, topRight.Y - 5)
                elseif self.Settings.HealthBarPosition == "Bottom" then
                    playerData.Drawings.HealthBarBackground.From = Vector2new(bottomLeft.X, bottomLeft.Y + 5)
                    playerData.Drawings.HealthBarBackground.To = Vector2new(bottomRight.X, bottomRight.Y + 5)
                end
                
                playerData.Drawings.HealthBarBackground.Transparency = transparency * self.Settings.HealthBarTransparency
                playerData.Drawings.HealthBarBackground.Visible = true
            else
                playerData.Drawings.HealthBar.Visible = false
                playerData.Drawings.HealthBarOutline.Visible = false
                playerData.Drawings.HealthBarBackground.Visible = false
            end
        else
            playerData.Drawings.Health.Visible = false
            playerData.Drawings.HealthBar.Visible = false
            playerData.Drawings.HealthBarOutline.Visible = false
            playerData.Drawings.HealthBarBackground.Visible = false
        end
    else
        playerData.Drawings.Health.Visible = false
        playerData.Drawings.HealthBar.Visible = false
        playerData.Drawings.HealthBarOutline.Visible = false
        playerData.Drawings.HealthBarBackground.Visible = false
    end
    
    if self.Settings.TracerEnabled then
        local screenPos, onScreen = self:WorldToScreen(hrp.Position)
        
        if onScreen then
            local from
            
            if self.Settings.TracerOrigin == "Bottom" then
                from = Vector2new(Camera.ViewportSize.X / 2 + self.Settings.TracerXOffset, Camera.ViewportSize.Y + self.Settings.TracerYOffset)
            elseif self.Settings.TracerOrigin == "Center" then
                from = Vector2new(Camera.ViewportSize.X / 2 + self.Settings.TracerXOffset, Camera.ViewportSize.Y / 2 + self.Settings.TracerYOffset)
            elseif self.Settings.TracerOrigin == "Mouse" then
                from = GetMouseLocation(UserInputService) + Vector2new(self.Settings.TracerXOffset, self.Settings.TracerYOffset)
            end
            
            for _, line in pairs(playerData.Drawings.TracerDashed) do
                self:RemoveDrawing(line)
            end
            playerData.Drawings.TracerDashed = {}
            
            if self.Settings.TracerStyle == "Line" then
                playerData.Drawings.Tracer.From = from
                playerData.Drawings.Tracer.To = screenPos
                playerData.Drawings.Tracer.Color = self.Settings.TeamColor and player.TeamColor.Color or self.Settings.TracerColor
                playerData.Drawings.Tracer.Transparency = transparency * self.Settings.TracerTransparency
                playerData.Drawings.Tracer.Visible = true
                
                if self.Settings.TracerOutline then
                    playerData.Drawings.TracerOutline.From = from
                    playerData.Drawings.TracerOutline.To = screenPos
                    playerData.Drawings.TracerOutline.Transparency = transparency * self.Settings.TracerOutlineTransparency
                    playerData.Drawings.TracerOutline.Visible = true
                else
                    playerData.Drawings.TracerOutline.Visible = false
                end
            elseif self.Settings.TracerStyle == "Dashed" or self.Settings.TracerStyle == "Dotted" then
                playerData.Drawings.Tracer.Visible = false
                playerData.Drawings.TracerOutline.Visible = false
                
                local dashSize = self.Settings.TracerStyle == "Dotted" and 1 or self.Settings.TracerDashSize
                local gapSize = self.Settings.TracerDashGap
                
                playerData.Drawings.TracerDashed = self:DrawDashedLine(
                    from, 
                    screenPos, 
                    dashSize, 
                    gapSize, 
                    self.Settings.TeamColor and player.TeamColor.Color or self.Settings.TracerColor, 
                    self.Settings.TracerThickness, 
                    transparency * self.Settings.TracerTransparency, 
                    self.Settings.ZIndex
                )
            end
        else
            playerData.Drawings.Tracer.Visible = false
            playerData.Drawings.TracerOutline.Visible = false
            
            for _, line in pairs(playerData.Drawings.TracerDashed) do
                line.Visible = false
            end
        end
    else
        playerData.Drawings.Tracer.Visible = false
        playerData.Drawings.TracerOutline.Visible = false
        
        for _, line in pairs(playerData.Drawings.TracerDashed) do
            line.Visible = false
        end
    end
    
    if self.Settings.WeaponEnabled then
        local screenPos, onScreen = self:WorldToScreen(head.Position)
        
        if onScreen then
            local weapon = self:GetWeapon(player)
            local textSize = self:CalculateTextSize(distance)
            local weaponPosition = self:CalculatePosition(
                self.Settings.WeaponPosition, 
                boxCorners, 
                screenPos, 
                self.Settings.WeaponXOffset, 
                self.Settings.WeaponYOffset
            )
            
            playerData.Drawings.Weapon.Position = weaponPosition
            playerData.Drawings.Weapon.Text = weapon
            playerData.Drawings.Weapon.Color = self.Settings.TeamColor and player.TeamColor.Color or self.Settings.WeaponColor
            playerData.Drawings.Weapon.Transparency = transparency * self.Settings.WeaponTransparency
            playerData.Drawings.Weapon.Size = textSize
            playerData.Drawings.Weapon.Visible = true
        else
            playerData.Drawings.Weapon.Visible = false
        end
    else
        playerData.Drawings.Weapon.Visible = false
    end
    
    if self.Settings.SkeletonEnabled then
        local skeletonConnections = {
            {"Head", "UpperTorso"},
            {"UpperTorso", "LowerTorso"},
            {"UpperTorso", "LeftUpperArm"},
            {"LeftUpperArm", "LeftLowerArm"},
            {"LeftLowerArm", "LeftHand"},
            {"UpperTorso", "RightUpperArm"},
            {"RightUpperArm", "RightLowerArm"},
            {"RightLowerArm", "RightHand"},
            {"LowerTorso", "LeftUpperLeg"},
            {"LeftUpperLeg", "LeftLowerLeg"},
            {"LeftLowerLeg", "LeftFoot"},
            {"LowerTorso", "RightUpperLeg"},
            {"RightUpperLeg", "RightLowerLeg"},
            {"RightLowerLeg", "RightFoot"}
        }
        
        for i, connection in ipairs(skeletonConnections) do
            local part1 = character:FindFirstChild(connection[1])
            local part2 = character:FindFirstChild(connection[2])
            
            if part1 and part2 then
                local pos1, onScreen1 = self:WorldToScreen(part1.Position)
                local pos2, onScreen2 = self:WorldToScreen(part2.Position)
                
                if onScreen1 and onScreen2 and i <= #playerData.Drawings.Skeleton then
                    playerData.Drawings.Skeleton[i].Line.From = pos1
                    playerData.Drawings.Skeleton[i].Line.To = pos2
                    playerData.Drawings.Skeleton[i].Line.Color = self.Settings.TeamColor and player.TeamColor.Color or self.Settings.SkeletonColor
                    playerData.Drawings.Skeleton[i].Line.Transparency = transparency * self.Settings.SkeletonTransparency
                    playerData.Drawings.Skeleton[i].Line.Visible = true
                    
                    if self.Settings.SkeletonOutline then
                        playerData.Drawings.Skeleton[i].Outline.From = pos1
                        playerData.Drawings.Skeleton[i].Outline.To = pos2
                        playerData.Drawings.Skeleton[i].Outline.Transparency = transparency * self.Settings.SkeletonOutlineTransparency
                        playerData.Drawings.Skeleton[i].Outline.Visible = true
                    else
                        playerData.Drawings.Skeleton[i].Outline.Visible = false
                    end
                else
                    playerData.Drawings.Skeleton[i].Line.Visible = false
                    playerData.Drawings.Skeleton[i].Outline.Visible = false
                end
            else
                if i <= #playerData.Drawings.Skeleton then
                    playerData.Drawings.Skeleton[i].Line.Visible = false
                    playerData.Drawings.Skeleton[i].Outline.Visible = false
                end
            end
        end
    else
        for _, connection in pairs(playerData.Drawings.Skeleton) do
            connection.Line.Visible = false
            connection.Outline.Visible = false
        end
    end
    
    if self.Settings.HeadDotEnabled then
        local screenPos, onScreen = self:WorldToScreen(head.Position)
        
        if onScreen then
            local size = self.Settings.HeadDotSize / (distance / 100)
            
            playerData.Drawings.HeadDot.Position = screenPos
            playerData.Drawings.HeadDot.Radius = size
            playerData.Drawings.HeadDot.Color = self.Settings.TeamColor and player.TeamColor.Color or self.Settings.HeadDotColor
            playerData.Drawings.HeadDot.Transparency = transparency * self.Settings.HeadDotTransparency
            playerData.Drawings.HeadDot.Visible = true
            
            if self.Settings.HeadDotOutline then
                playerData.Drawings.HeadDotOutline.Position = screenPos
                playerData.Drawings.HeadDotOutline.Radius = size
                playerData.Drawings.HeadDotOutline.Transparency = transparency * self.Settings.HeadDotOutlineTransparency
                playerData.Drawings.HeadDotOutline.Visible = true
            else
                playerData.Drawings.HeadDotOutline.Visible = false
            end
            
            if self.Settings.HeadDotFilled then
                playerData.Drawings.HeadDotFill.Position = screenPos
                playerData.Drawings.HeadDotFill.Radius = size
                playerData.Drawings.HeadDotFill.Color = self.Settings.TeamColor and player.TeamColor.Color or self.Settings.HeadDotColor
                playerData.Drawings.HeadDotFill.Transparency = transparency * self.Settings.HeadDotFilledTransparency
                playerData.Drawings.HeadDotFill.Visible = true
            else
                playerData.Drawings.HeadDotFill.Visible = false
            end
        else
            playerData.Drawings.HeadDot.Visible = false
            playerData.Drawings.HeadDotOutline.Visible = false
            playerData.Drawings.HeadDotFill.Visible = false
        end
    else
        playerData.Drawings.HeadDot.Visible = false
        playerData.Drawings.HeadDotOutline.Visible = false
        playerData.Drawings.HeadDotFill.Visible = false
    end
    
    if self.Settings.ChamsEnabled then
        if not playerData.Drawings.Chams.Enabled then
            playerData.Drawings.Chams.Highlight.Parent = game.CoreGui
            playerData.Drawings.Chams.Highlight.Adornee = character
            playerData.Drawings.Chams.Highlight.Enabled = true
            playerData.Drawings.Chams.Enabled = true
        end
        
        playerData.Drawings.Chams.Highlight.FillColor = self.Settings.TeamColor and player.TeamColor.Color or self.Settings.ChamsColor
        playerData.Drawings.Chams.Highlight.FillTransparency = 1 - (transparency * (1 - self.Settings.ChamsTransparency))
        
        if self.Settings.ChamsOutlineEnabled then
            playerData.Drawings.Chams.Highlight.OutlineColor = self.Settings.ChamsOutlineColor
            playerData.Drawings.Chams.Highlight.OutlineTransparency = 1 - (transparency * (1 - self.Settings.ChamsOutlineTransparency))
        else
            playerData.Drawings.Chams.Highlight.OutlineTransparency = 1
        end
        
        if self.Settings.ChamsDepthMode == "Occluded" then
            playerData.Drawings.Chams.Highlight.DepthMode = Enum.HighlightDepthMode.Occluded
        elseif self.Settings.ChamsDepthMode == "AlwaysOnTop" then
            playerData.Drawings.Chams.Highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        end
    else
        if playerData.Drawings.Chams.Enabled then
            playerData.Drawings.Chams.Highlight.Enabled = false
            playerData.Drawings.Chams.Enabled = false
        end
    end
end

function ESP:Update()
    for _, player in ipairs(GetPlayers(Players)) do
        if player ~= LocalPlayer then
            self:UpdatePlayer(player)
        end
    end
    
    for _, objectData in pairs(self.Objects) do
        self:UpdateObjectESP(objectData.Object)
    end
end

function ESP:CreateObjectESP(object, customSettings)
    if not object then return end
    
    local objectId = tostring(object:GetFullName())
    
    local settings = {}
    for key, value in pairs(self.Settings) do
        settings[key] = value
    end
    
    if customSettings then
        for key, value in pairs(customSettings) do
            settings[key] = value
        end
    end
    
    local objectData = {
        Object = object,
        Settings = settings,
        Drawings = {
            Box = self:CreateDrawing("Square", {
                Visible = false,
                Color = settings.BoxColor,
                Thickness = settings.BoxThickness,
                Transparency = settings.BoxTransparency,
                Filled = settings.BoxFilled,
                ZIndex = settings.ZIndex
            }),
            BoxOutline = self:CreateDrawing("Square", {
                Visible = false,
                Color = settings.BoxOutlineColor,
                Thickness = settings.BoxThickness + 2,
                Transparency = settings.BoxOutlineTransparency,
                Filled = false,
                ZIndex = settings.ZIndex - 1
            }),
            BoxFill = self:CreateDrawing("Square", {
                Visible = false,
                Color = settings.BoxColor,
                Transparency = settings.BoxFilledTransparency,
                Filled = true,
                ZIndex = settings.ZIndex - 2
            }),
            BoxCorners = {},
            Box3D = {},
            Name = self:CreateDrawing("Text", {
                Visible = false,
                Color = settings.NameColor,
                Transparency = settings.NameTransparency,
                Size = settings.NameSize,
                Center = true,
                Outline = settings.NameOutline,
                OutlineColor = settings.NameOutlineColor,
                Font = settings.NameFont,
                ZIndex = settings.ZIndex
            }),
            Distance = self:CreateDrawing("Text", {
                Visible = false,
                Color = settings.DistanceColor,
                Transparency = settings.DistanceTransparency,
                Size = settings.DistanceSize,
                Center = true,
                Outline = settings.DistanceOutline,
                OutlineColor = settings.DistanceOutlineColor,
                Font = settings.DistanceFont,
                ZIndex = settings.ZIndex
            }),
            Tracer = self:CreateDrawing("Line", {
                Visible = false,
                Color = settings.TracerColor,
                Thickness = settings.TracerThickness,
                Transparency = settings.TracerTransparency,
                ZIndex = settings.ZIndex
            }),
            TracerOutline = self:CreateDrawing("Line", {
                Visible = false,
                Color = settings.TracerOutlineColor,
                Thickness = settings.TracerThickness + 2,
                Transparency = settings.TracerOutlineTransparency,
                ZIndex = settings.ZIndex - 1
            }),
            TracerDashed = {}
        }
    }
    
    for i = 1, 8 do
        objectData.Drawings.BoxCorners[i] = {
            Line = self:CreateDrawing("Line", {
                Visible = false,
                Color = settings.BoxColor,
                Thickness = settings.BoxThickness,
                Transparency = settings.BoxTransparency,
                ZIndex = settings.ZIndex
            }),
            Outline = self:CreateDrawing("Line", {
                Visible = false,
                Color = settings.BoxOutlineColor,
                Thickness = settings.BoxThickness + 2,
                Transparency = settings.BoxOutlineTransparency,
                ZIndex = settings.ZIndex - 1
            })
        }
    end
    
    for i = 1, 12 do
        objectData.Drawings.Box3D[i] = {
            Line = self:CreateDrawing("Line", {
                Visible = false,
                Color = settings.BoxColor,
                Thickness = settings.BoxThickness,
                Transparency = settings.BoxTransparency,
                ZIndex = settings.ZIndex
            }),
            Outline = self:CreateDrawing("Line", {
                Visible = false,
                Color = settings.BoxOutlineColor,
                Thickness = settings.BoxThickness + 2,
                Transparency = settings.BoxOutlineTransparency,
                ZIndex = settings.ZIndex - 1
            })
        }
    end
    
    self.Objects[objectId] = objectData
    return objectData
end

function ESP:UpdateObjectESP(object)
    local objectId = tostring(object:GetFullName())
    local objectData = self.Objects[objectId]
    
    if not objectData then return end
    
    local position
    if object:IsA("Model") then
        local primaryPart = object.PrimaryPart or object:FindFirstChildWhichIsA("BasePart")
        if not primaryPart then return end
        position = primaryPart.Position
    elseif object:IsA("BasePart") then
        position = object.Position
    else
        return
    end
    
    local distance = self:GetDistance(position)
    if distance > objectData.Settings.MaxDistance then
        for _, drawing in pairs(objectData.Drawings) do
            if type(drawing) == "table" then
                if drawing.Line then
                    drawing.Line.Visible = false
                    drawing.Outline.Visible = false
                else
                    for _, subDrawing in pairs(drawing) do
                        if type(subDrawing) == "table" then
                            subDrawing.Line.Visible = false
                            subDrawing.Outline.Visible = false
                        else
                            subDrawing.Visible = false
                        end
                    end
                end
            else
                drawing.Visible = false
            end
        end
        return
    end
    
    local transparency = self:CalculateTransparency(distance)
    
    if objectData.Settings.BoxEnabled then
        local boxCorners = self:GetBoxCorners(object)
        
        objectData.Drawings.Box.Visible = false
        objectData.Drawings.BoxOutline.Visible = false
        objectData.Drawings.BoxFill.Visible = false
        
        for _, corner in pairs(objectData.Drawings.BoxCorners) do
            corner.Line.Visible = false
            corner.Outline.Visible = false
        end
        
        for _, line in pairs(objectData.Drawings.Box3D) do
            line.Line.Visible = false
            line.Outline.Visible = false
        end
        
        if boxCorners then
            local topLeft = boxCorners.TopLeft
            local bottomRight = boxCorners.BottomRight
            local boxSize = bottomRight - topLeft
            
            if objectData.Settings.BoxType == "2D" then
                objectData.Drawings.Box.Position = topLeft
                objectData.Drawings.Box.Size = boxSize
                objectData.Drawings.Box.Color = objectData.Settings.BoxColor
                objectData.Drawings.Box.Transparency = transparency * objectData.Settings.BoxTransparency
                objectData.Drawings.Box.Visible = true
                
                if objectData.Settings.BoxOutline then
                    objectData.Drawings.BoxOutline.Position = topLeft
                    objectData.Drawings.BoxOutline.Size = boxSize
                    objectData.Drawings.BoxOutline.Transparency = transparency * objectData.Settings.BoxOutlineTransparency
                    objectData.Drawings.BoxOutline.Visible = true
                end
                
                if objectData.Settings.BoxFilled then
                    objectData.Drawings.BoxFill.Position = topLeft
                    objectData.Drawings.BoxFill.Size = boxSize
                    objectData.Drawings.BoxFill.Color = objectData.Settings.BoxColor
                    objectData.Drawings.BoxFill.Transparency = transparency * objectData.Settings.BoxFilledTransparency
                    objectData.Drawings.BoxFill.Visible = true
                end
            elseif objectData.Settings.BoxType == "Corner" then
                local cornerPoints = self:GetCornerBoxPoints(boxCorners)
                
                if cornerPoints then
                    for i, points in ipairs(cornerPoints) do
                        if i <= #objectData.Drawings.BoxCorners then
                            objectData.Drawings.BoxCorners[i].Line.From = points[1]
                            objectData.Drawings.BoxCorners[i].Line.To = points[2]
                            objectData.Drawings.BoxCorners[i].Line.Color = objectData.Settings.BoxColor
                            objectData.Drawings.BoxCorners[i].Line.Transparency = transparency * objectData.Settings.BoxTransparency
                            objectData.Drawings.BoxCorners[i].Line.Visible = true
                            
                            if objectData.Settings.BoxOutline then
                                objectData.Drawings.BoxCorners[i].Outline.From = points[1]
                                objectData.Drawings.BoxCorners[i].Outline.To = points[2]
                                objectData.Drawings.BoxCorners[i].Outline.Transparency = transparency * objectData.Settings.BoxOutlineTransparency
                                objectData.Drawings.BoxCorners[i].Outline.Visible = true
                            end
                        end
                    end
                end
            elseif objectData.Settings.BoxType == "3D" then
                local corners3D = self:Get3DBoxCorners(object)
                
                if corners3D then
                    local edges = {
                        {1, 2}, {2, 4}, {4, 3}, {3, 1},
                        {5, 6}, {6, 8}, {8, 7}, {7, 5},
                        {1, 5}, {2, 6}, {3, 7}, {4, 8}
                    }
                    
                    for i, edge in ipairs(edges) do
                        if i <= #objectData.Drawings.Box3D then
                            objectData.Drawings.Box3D[i].Line.From = Vector2new(corners3D[edge[1]].X, corners3D[edge[1]].Y)
                            objectData.Drawings.Box3D[i].Line.To = Vector2new(corners3D[edge[2]].X, corners3D[edge[2]].Y)
                            objectData.Drawings.Box3D[i].Line.Color = objectData.Settings.BoxColor
                            objectData.Drawings.Box3D[i].Line.Transparency = transparency * objectData.Settings.BoxTransparency
                            objectData.Drawings.Box3D[i].Line.Visible = true
                            
                            if objectData.Settings.BoxOutline then
                                objectData.Drawings.Box3D[i].Outline.From = Vector2new(corners3D[edge[1]].X, corners3D[edge[1]].Y)
                                objectData.Drawings.Box3D[i].Outline.To = Vector2new(corners3D[edge[2]].X, corners3D[edge[2]].Y)
                                objectData.Drawings.Box3D[i].Outline.Transparency = transparency * objectData.Settings.BoxOutlineTransparency
                                objectData.Drawings.Box3D[i].Outline.Visible = true
                            end
                        end
                    end
                end
            end
        end
    else
        objectData.Drawings.Box.Visible = false
        objectData.Drawings.BoxOutline.Visible = false
        objectData.Drawings.BoxFill.Visible = false
        
        for _, corner in pairs(objectData.Drawings.BoxCorners) do
            corner.Line.Visible = false
            corner.Outline.Visible = false
        end
        
        for _, line in pairs(objectData.Drawings.Box3D) do
            line.Line.Visible = false
            line.Outline.Visible = false
        end
    end
    
    if objectData.Settings.NameEnabled then
        local screenPos, onScreen, depth = self:WorldToScreen(position)
        local boxCorners = self:GetBoxCorners(object)
        
        if onScreen then
            local displayName = object.Name
            local textSize = self:CalculateTextSize(distance)
            local namePosition = self:CalculatePosition(
                objectData.Settings.NamePosition, 
                boxCorners, 
                screenPos, 
                objectData.Settings.NameXOffset, 
                objectData.Settings.NameYOffset
            )
            
            objectData.Drawings.Name.Position = namePosition
            objectData.Drawings.Name.Text = displayName
            objectData.Drawings.Name.Transparency = transparency * objectData.Settings.NameTransparency
            objectData.Drawings.Name.Size = textSize
            objectData.Drawings.Name.Visible = true
        else
            objectData.Drawings.Name.Visible = false
        end
    else
        objectData.Drawings.Name.Visible = false
    end
    
    if objectData.Settings.DistanceEnabled then
        local screenPos, onScreen, depth = self:WorldToScreen(position)
        local boxCorners = self:GetBoxCorners(object)
        
        if onScreen then
            local distanceText = self:GetDistanceText(distance)
            local textSize = self:CalculateTextSize(distance)
            local distancePosition = self:CalculatePosition(
                objectData.Settings.DistancePosition, 
                boxCorners, 
                screenPos, 
                objectData.Settings.DistanceXOffset, 
                objectData.Settings.DistanceYOffset
            )
            
            objectData.Drawings.Distance.Position = distancePosition
            objectData.Drawings.Distance.Text = distanceText
            objectData.Drawings.Distance.Transparency = transparency * objectData.Settings.DistanceTransparency
            objectData.Drawings.Distance.Size = textSize
            objectData.Drawings.Distance.Visible = true
        else
            objectData.Drawings.Distance.Visible = false
        end
    else
        objectData.Drawings.Distance.Visible = false
    end
    
    if objectData.Settings.TracerEnabled then
        local screenPos, onScreen, depth = self:WorldToScreen(position)
        
        if onScreen then
            local from
            
            if objectData.Settings.TracerOrigin == "Bottom" then
                from = Vector2new(Camera.ViewportSize.X / 2 + objectData.Settings.TracerXOffset, Camera.ViewportSize.Y + objectData.Settings.TracerYOffset)
            elseif objectData.Settings.TracerOrigin == "Center" then
                from = Vector2new(Camera.ViewportSize.X / 2 + objectData.Settings.TracerXOffset, Camera.ViewportSize.Y / 2 + objectData.Settings.TracerYOffset)
            elseif objectData.Settings.TracerOrigin == "Mouse" then
                from = GetMouseLocation(UserInputService) + Vector2new(objectData.Settings.TracerXOffset, objectData.Settings.TracerYOffset)
            end
            
            for _, line in pairs(objectData.Drawings.TracerDashed) do
                self:RemoveDrawing(line)
            end
            objectData.Drawings.TracerDashed = {}
            
            if objectData.Settings.TracerStyle == "Line" then
                objectData.Drawings.Tracer.From = from
                objectData.Drawings.Tracer.To = screenPos
                objectData.Drawings.Tracer.Color = objectData.Settings.TracerColor
                objectData.Drawings.Tracer.Transparency = transparency * objectData.Settings.TracerTransparency
                objectData.Drawings.Tracer.Visible = true
                
                if objectData.Settings.TracerOutline then
                    objectData.Drawings.TracerOutline.From = from
                    objectData.Drawings.TracerOutline.To = screenPos
                    objectData.Drawings.TracerOutline.Transparency = transparency * objectData.Settings.TracerOutlineTransparency
                    objectData.Drawings.TracerOutline.Visible = true
                else
                    objectData.Drawings.TracerOutline.Visible = false
                end
            elseif objectData.Settings.TracerStyle == "Dashed" or objectData.Settings.TracerStyle == "Dotted" then
                objectData.Drawings.Tracer.Visible = false
                objectData.Drawings.TracerOutline.Visible = false
                
                local dashSize = objectData.Settings.TracerStyle == "Dotted" and 1 or objectData.Settings.TracerDashSize
                local gapSize = objectData.Settings.TracerDashGap
                
                objectData.Drawings.TracerDashed = self:DrawDashedLine(
                    from, 
                    screenPos, 
                    dashSize, 
                    gapSize, 
                    objectData.Settings.TracerColor, 
                    objectData.Settings.TracerThickness, 
                    transparency * objectData.Settings.TracerTransparency, 
                    objectData.Settings.ZIndex
                )
            end
        else
            objectData.Drawings.Tracer.Visible = false
            objectData.Drawings.TracerOutline.Visible = false
            
            for _, line in pairs(objectData.Drawings.TracerDashed) do
                line.Visible = false
            end
        end
    else
        objectData.Drawings.Tracer.Visible = false
        objectData.Drawings.TracerOutline.Visible = false
        
        for _, line in pairs(objectData.Drawings.TracerDashed) do
            line.Visible = false
        end
    end
end

function ESP:Add(object, customSettings)
    if not object then return end
    
    local objectId = tostring(object:GetFullName())
    
    if self.Objects[objectId] then
        return self.Objects[objectId]
    end
    
    return self:CreateObjectESP(object, customSettings)
end

function ESP:AddBox(object, options)
    local customSettings = options or {}
    customSettings.BoxEnabled = true
    customSettings.NameEnabled = false
    customSettings.DistanceEnabled = false
    customSettings.TracerEnabled = false
    
    return self:Add(object, customSettings)
end

function ESP:AddName(object, options)
    local customSettings = options or {}
    customSettings.BoxEnabled = false
    customSettings.NameEnabled = true
    customSettings.DistanceEnabled = false
    customSettings.TracerEnabled = false
    
    return self:Add(object, customSettings)
end

function ESP:AddDistance(object, options)
    local customSettings = options or {}
    customSettings.BoxEnabled = false
    customSettings.NameEnabled = false
    customSettings.DistanceEnabled = true
    customSettings.TracerEnabled = false
    
    return self:Add(object, customSettings)
end

function ESP:AddTracer(object, options)
    local customSettings = options or {}
    customSettings.BoxEnabled = false
    customSettings.NameEnabled = false
    customSettings.DistanceEnabled = false
    customSettings.TracerEnabled = true
    
    return self:Add(object, customSettings)
end

function ESP:AddFull(object, options)
    local customSettings = options or {}
    customSettings.BoxEnabled = true
    customSettings.NameEnabled = true
    customSettings.DistanceEnabled = true
    customSettings.TracerEnabled = true
    
    return self:Add(object, customSettings)
end

function ESP:AddMultiple(objects, options)
    if not objects then return end
    
    local results = {}
    
    for _, object in ipairs(objects) do
        table.insert(results, self:Add(object, options))
    end
    
    return results
end

function ESP:Remove(object)
    if not object then return end
    
    local objectId = tostring(object:GetFullName())
    local objectData = self.Objects[objectId]
    
    if objectData then
        for _, drawing in pairs(objectData.Drawings) do
            self:RemoveDrawing(drawing)
        end
        
        self.Objects[objectId] = nil
    end
end

function ESP:RemoveAll()
    for objectId, objectData in pairs(self.Objects) do
        for _, drawing in pairs(objectData.Drawings) do
            self:RemoveDrawing(drawing)
        end
    end
    
    clear(self.Objects)
end

function ESP:GetBoxSize(object)
    if object:IsA("Model") then
        return object:GetExtentsSize()
    elseif object:IsA("BasePart") then
        return object.Size
    end
    
    return Vector3new(4, 5, 4)
end

function ESP:GetBoxCenter(object)
    if object:IsA("Model") then
        return object:GetBoundingBox().Position
    elseif object:IsA("BasePart") then
        return object.Position
    end
    
    return Vector3new(0, 0, 0)
end

function ESP:SetLighting(enabled)
    if enabled then
        self.Settings.LightingEnabled = true
        
        self.OriginalLighting = {
            Brightness = Lighting.Brightness,
            ClockTime = Lighting.ClockTime,
            FogEnd = Lighting.FogEnd,
            GlobalShadows = Lighting.GlobalShadows,
            OutdoorAmbient = Lighting.OutdoorAmbient
        }
        
        Lighting.Brightness = 2
        Lighting.ClockTime = 14
        Lighting.FogEnd = 100000
        Lighting.GlobalShadows = false
        Lighting.OutdoorAmbient = Color3fromRGB(128, 128, 128)
    else
        self.Settings.LightingEnabled = false
        
        if self.OriginalLighting then
            Lighting.Brightness = self.OriginalLighting.Brightness
            Lighting.ClockTime = self.OriginalLighting.ClockTime
            Lighting.FogEnd = self.OriginalLighting.FogEnd
            Lighting.GlobalShadows = self.OriginalLighting.GlobalShadows
            Lighting.OutdoorAmbient = self.OriginalLighting.OutdoorAmbient
        end
    end
end

function ESP:Toggle(enabled)
    if enabled ~= nil then
        self.Enabled = enabled
    else
        self.Enabled = not self.Enabled
    end
    
    return self.Enabled
end

function ESP:ToggleBox(enabled)
    if enabled ~= nil then
        self.Settings.BoxEnabled = enabled
    else
        self.Settings.BoxEnabled = not self.Settings.BoxEnabled
    end
    
    return self.Settings.BoxEnabled
end

function ESP:ToggleName(enabled)
    if enabled ~= nil then
        self.Settings.NameEnabled = enabled
    else
        self.Settings.NameEnabled = not self.Settings.NameEnabled
    end
    
    return self.Settings.NameEnabled
end

function ESP:ToggleDistance(enabled)
    if enabled ~= nil then
        self.Settings.DistanceEnabled = enabled
    else
        self.Settings.DistanceEnabled = not self.Settings.DistanceEnabled
    end
    
    return self.Settings.DistanceEnabled
end

function ESP:ToggleHealth(enabled)
    if enabled ~= nil then
        self.Settings.HealthEnabled = enabled
    else
        self.Settings.HealthEnabled = not self.Settings.HealthEnabled
    end
    
    return self.Settings.HealthEnabled
end

function ESP:ToggleTracer(enabled)
    if enabled ~= nil then
        self.Settings.TracerEnabled = enabled
    else
        self.Settings.TracerEnabled = not self.Settings.TracerEnabled
    end
    
    return self.Settings.TracerEnabled
end

function ESP:ToggleChams(enabled)
    if enabled ~= nil then
        self.Settings.ChamsEnabled = enabled
    else
        self.Settings.ChamsEnabled = not self.Settings.ChamsEnabled
    end
    
    return self.Settings.ChamsEnabled
end

function ESP:ToggleSkeleton(enabled)
    if enabled ~= nil then
        self.Settings.SkeletonEnabled = enabled
    else
        self.Settings.SkeletonEnabled = not self.Settings.SkeletonEnabled
    end
    
    return self.Settings.SkeletonEnabled
end

function ESP:ToggleHeadDot(enabled)
    if enabled ~= nil then
        self.Settings.HeadDotEnabled = enabled
    else
        self.Settings.HeadDotEnabled = not self.Settings.HeadDotEnabled
    end
    
    return self.Settings.HeadDotEnabled
end

function ESP:ToggleWeapon(enabled)
    if enabled ~= nil then
        self.Settings.WeaponEnabled = enabled
    else
        self.Settings.WeaponEnabled = not self.Settings.WeaponEnabled
    end
    
    return self.Settings.WeaponEnabled
end

function ESP:ToggleTeamCheck(enabled)
    if enabled ~= nil then
        self.Settings.TeamCheck = enabled
    else
        self.Settings.TeamCheck = not self.Settings.TeamCheck
    end
    
    return self.Settings.TeamCheck
end

function ESP:ToggleTeamColor(enabled)
    if enabled ~= nil then
        self.Settings.TeamColor = enabled
    else
        self.Settings.TeamColor = not self.Settings.TeamColor
    end
    
    return self.Settings.TeamColor
end

function ESP:ToggleFriendCheck(enabled)
    if enabled ~= nil then
        self.Settings.FriendCheck = enabled
    else
        self.Settings.FriendCheck = not self.Settings.FriendCheck
    end
    
    return self.Settings.FriendCheck
end

function ESP:SetColor(color)
    self.Settings.BoxColor = color
    self.Settings.NameColor = color
    self.Settings.DistanceColor = color
    self.Settings.TracerColor = color
    self.Settings.HeadDotColor = color
    self.Settings.SkeletonColor = color
end

function ESP:SetOutlineColor(color)
    self.Settings.BoxOutlineColor = color
    self.Settings.NameOutlineColor = color
    self.Settings.DistanceOutlineColor = color
    self.Settings.TracerOutlineColor = color
    self.Settings.HeadDotOutlineColor = color
    self.Settings.SkeletonOutlineColor = color
end

function ESP:SetMaxDistance(distance)
    self.Settings.MaxDistance = distance
end

function ESP:SetMinDistance(distance)
    self.Settings.MinDistance = distance
end

function ESP:SetBoxType(boxType)
    self.Settings.BoxType = boxType
end

function ESP:SetTracerOrigin(origin)
    self.Settings.TracerOrigin = origin
end

function ESP:SetTracerStyle(style)
    self.Settings.TracerStyle = style
end

function ESP:SetHealthBarPosition(position)
    self.Settings.HealthBarPosition = position
end

function ESP:SetChamsDepthMode(mode)
    self.Settings.ChamsDepthMode = mode
end

function ESP:GetSettings()
    return self.Settings
end

function ESP:SetSettings(settings)
    for key, value in pairs(settings) do
        self.Settings[key] = value
    end
end

function ESP:ResetSettings()
    self.Settings = {
        BoxEnabled = true,
        BoxType = "2D",
        BoxColor = Color3.new(1, 1, 1),
        BoxThickness = 1,
        BoxTransparency = 1,
        BoxOutline = true,
        BoxOutlineColor = Color3.new(0, 0, 0),
        BoxOutlineTransparency = 1,
        BoxFilled = false,
        BoxFilledTransparency = 0.5,
        BoxPadding = Vector3.new(0, 0, 0),
        
        NameEnabled = true,
        NameColor = Color3.new(1, 1, 1),
        NameTransparency = 1,
        NameSize = 13,
        NameOutline = true,
        NameOutlineColor = Color3.new(0, 0, 0),
        NameFont = 0,
        NamePosition = "Top",
        NameXOffset = 0,
        NameYOffset = 0,
        
        DistanceEnabled = true,
        DistanceColor = Color3.new(1, 1, 1),
        DistanceTransparency = 1,
        DistanceSize = 13,
        DistanceOutline = true,
        DistanceOutlineColor = Color3.new(0, 0, 0),
        DistanceFont = 0,
        DistancePosition = "Bottom",
        DistanceXOffset = 0,
        DistanceYOffset = 0,
        
        HealthEnabled = true,
        HealthColor = Color3.new(0, 1, 0),
        HealthTransparency = 1,
        HealthSize = 13,
        HealthOutline = true,
        HealthOutlineColor = Color3.new(0, 0, 0),
        HealthFont = 0,
        HealthPosition = "Left",
        HealthXOffset = 0,
        HealthYOffset = 0,
        HealthAutoColor = true,
        HealthBarEnabled = true,
        HealthBarThickness = 1,
        HealthBarTransparency = 1,
        HealthBarOutline = true,
        HealthBarOutlineColor = Color3.new(0, 0, 0),
        HealthBarOutlineTransparency = 1,
        HealthBarFilled = true,
        HealthBarFilledTransparency = 0.5,
        HealthBarPosition = "Bottom",
        HealthBarXOffset = 0,
        HealthBarYOffset = 0,
        HealthBarSide = "Left",
        
        TracerEnabled = true,
        TracerColor = Color3.new(1, 1, 1),
        TracerTransparency = 1,
        TracerThickness = 1,
        TracerOutline = true,
        TracerOutlineColor = Color3.new(0, 0, 0),
        TracerOutlineTransparency = 1,
        TracerOrigin = "Bottom",
        TracerXOffset = 0,
        TracerYOffset = 0,
        TracerStyle = "Line",
        TracerDashSize = 3,
        TracerDashGap = 2,
        
        ChamsEnabled = false,
        ChamsColor = Color3.new(1, 0, 0),
        ChamsTransparency = 0.5,
        ChamsOutlineColor = Color3.new(0, 0, 0),
        ChamsOutlineTransparency = 0,
        ChamsOutlineEnabled = false,
        ChamsDepthMode = "Occluded",
        
        SkeletonEnabled = false,
        SkeletonColor = Color3.new(1, 1, 1),
        SkeletonTransparency = 1,
        SkeletonThickness = 1,
        SkeletonOutline = true,
        SkeletonOutlineColor = Color3.new(0, 0, 0),
        SkeletonOutlineTransparency = 1,
        
        HeadDotEnabled = false,
        HeadDotColor = Color3.new(1, 0, 0),
        HeadDotTransparency = 1,
        HeadDotThickness = 1,
        HeadDotOutline = true,
        HeadDotOutlineColor = Color3.new(0, 0, 0),
        HeadDotOutlineTransparency = 1,
        HeadDotSize = 5,
        HeadDotFilled = true,
        HeadDotFilledTransparency = 0.5,
        
        WeaponEnabled = false,
        WeaponColor = Color3.new(1, 1, 1),
        WeaponTransparency = 1,
        WeaponSize = 13,
        WeaponOutline = true,
        WeaponOutlineColor = Color3.new(0, 0, 0),
        WeaponFont = 0,
        WeaponPosition = "Bottom",
        WeaponXOffset = 0,
        WeaponYOffset = 10,
        
        LightingEnabled = false,
        Brightness = 1,
        Contrast = 1,
        Saturation = 1,
        TintColor = Color3.new(1, 1, 1),
        
        TeamCheck = false,
        TeamColor = false,
        FriendCheck = false,
        
        MaxDistance = 1000,
        MinDistance = 0,
        
        ToggleKey = Enum.KeyCode.F1,
        BoxToggleKey = Enum.KeyCode.F2,
        NameToggleKey = Enum.KeyCode.F3,
        DistanceToggleKey = Enum.KeyCode.F4,
        HealthToggleKey = Enum.KeyCode.F5,
        TracerToggleKey = Enum.KeyCode.F6,
        ChamsToggleKey = Enum.KeyCode.F7,
        SkeletonToggleKey = Enum.KeyCode.F8,
        HeadDotToggleKey = Enum.KeyCode.F9,
        
        ZIndex = 1
    }
end

return ESP
