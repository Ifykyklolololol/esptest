
-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Constants stuff
local Vector2new = Vector2.new
local Vector3new = Vector3.new
local CFramenew = CFrame.new
local Color3new = Color3.new
local Color3fromRGB = Color3.fromRGB
local Color3fromHSV = Color3.fromHSV
local Drawingnew = Drawing.new
local WorldToViewportPoint = Camera.WorldToViewportPoint
local WorldToScreenPoint = Camera.WorldToScreenPoint
local RaycastParamsnew = RaycastParams.new
local EnumRaycastFilterTypeBlacklist = Enum.RaycastFilterType.Blacklist
local FindFirstChild = game.FindFirstChild
local IsA = game.IsA
local taskwait = task.wait
local taskspawn = task.spawn
local mathfloor = math.floor
local mathabs = math.abs
local mathclamp = math.clamp
local mathcos = math.cos
local mathsin = math.sin
local mathrad = math.rad
local mathhuge = math.huge
local mathmin = math.min
local mathmax = math.max
local mathpi = math.pi
local tableinsert = table.insert
local tableremove = table.remove
local tablefind = table.find
local stringsub = string.sub
local stringlen = string.len
local stringformat = string.format
local stringlower = string.lower

-- Start of lib
local ESP = {
    Enabled = true,
    Drawings = {},
    Players = {},
    Objects = {},
    Connections = {},
    
    -- some settings
    Settings = {
        -- basic
        RefreshRate = 0.01,
        MaxDistance = 1000,
        TeamCheck = false,
        VisibilityCheck = false,
        IgnoreInvisible = true,
        IgnoreDead = true,
        IgnoreNPCs = false,
        IgnoreFriends = false,
        UseDisplayName = false,
        AlwaysOnTop = true,
        DrawOnTop = true,
        ZIndex = 1,
        RenderPriority = 1,
        FadeWithDistance = true,
        VisibilityFade = true,
        SmoothTransitions = true,
        TransitionSpeed = 0.2,
        
        -- Box ESP
        BoxEnabled = true,
        BoxType = "2D", -- "2D", "3D", "Corner", "Filled", "Rounded", "Gradient"
        BoxColor = Color3fromRGB(255, 255, 255),
        BoxTransparency = 0.7,
        BoxThickness = 1,
        BoxFilled = false,
        BoxFilledTransparency = 0.3,
        BoxOutline = true,
        BoxOutlineColor = Color3fromRGB(0, 0, 0),
        BoxOutlineTransparency = 0.5,
        BoxRoundedRadius = 5,
        BoxGradientColor = Color3fromRGB(0, 0, 255),
        UsePartBoundingBox = true,
        BoxPadding = Vector3new(0.5, 0.5, 0.5),
        CornerSize = 8, -- Size of corner on corner boxes
        
        -- Name 
        NameEnabled = true,
        NameColor = Color3fromRGB(255, 255, 255),
        NameTransparency = 0.7,
        NameOutline = true,
        NameOutlineColor = Color3fromRGB(0, 0, 0),
        NameOutlineTransparency = 0.5,
        NameSize = 14,
        NameFont = 2, -- Drawing.Fonts.UI
        NamePosition = "top", -- top, bottom, left, right
        NameYOffset = -15, -- extra Y offset
        NameXOffset = 0, -- extra X offset
        NameBackground = true,
        NameBackgroundColor = Color3fromRGB(0, 0, 0),
        NameBackgroundTransparency = 0.5,
        NameBackgroundPadding = 2,
        
        -- Distance
        DistanceEnabled = true,
        DistanceColor = Color3fromRGB(255, 255, 255),
        DistanceTransparency = 0.7,
        DistanceOutline = true,
        DistanceOutlineColor = Color3fromRGB(0, 0, 0),
        DistanceOutlineTransparency = 0.5,
        DistanceSize = 13,
        DistanceFont = 2, -- Drawing.Fonts.UI
        DistancePosition = "bottom", -- top, bottom, left, right
        DistanceYOffset = 15, -- extra Y offset
        DistanceXOffset = 0, -- extra X offset
        DistanceTextSize = true, -- 
        DistanceBackground = true,
        DistanceBackgroundColor = Color3fromRGB(0, 0, 0),
        DistanceBackgroundTransparency = 0.5,
        DistanceBackgroundPadding = 2,
        
        -- Health
        HealthEnabled = true,
        HealthType = "Vertical", -- "Vertical", "Horizontal"
        HealthColor = Color3fromRGB(0, 255, 0),
        HealthTransparency = 0.7,
        HealthOutline = true,
        HealthOutlineColor = Color3fromRGB(0, 0, 0),
        HealthOutlineTransparency = 0.5,
        HealthThickness = 1,
        HealthPosition = "left", -- left, right, top, bottom
        HealthYOffset = 0, -- extra Y offset
        HealthXOffset = -5, -- extra X offset
        HealthBarThickness = 2,
        HealthGradient = true, -- Use gradient for health goes from green to red
        HealthBackground = true, -- Show background for health bar
        HealthBackgroundColor = Color3fromRGB(40, 40, 40),
        HealthBackgroundTransparency = 0.5,
        
        -- Tracers
        TracerEnabled = true,
        TracerColor = Color3fromRGB(255, 255, 255),
        TracerTransparency = 0.7,
        TracerThickness = 1,
        TracerOutline = true,
        TracerOutlineColor = Color3fromRGB(0, 0, 0),
        TracerOutlineTransparency = 0.5,
        TracerOrigin = "Bottom", -- "Bottom", "Center", "Mouse"
        TracerYOffset = 0, -- extra Y offset
        TracerXOffset = 0, -- extra X offset
        TracerStyle = "Line", -- "Line", "Dashed", "Dotted"
        TracerDashSize = 3, 
        TracerDashGap = 2, 
        
        -- Chams
        ChamsEnabled = true,
        ChamsColor = Color3fromRGB(255, 0, 0),
        ChamsTransparency = 0.5,
        ChamsOutlineColor = Color3fromRGB(0, 0, 0),
        ChamsOutlineTransparency = 0.5,
        ChamsUseTeamColor = false,
        ChamsVisibleOnly = false,
        ChamsHighlightMode = "Outline", -- "Outline", "Fill"
        
        -- Skeleton ESP
        SkeletonEnabled = true,
        SkeletonColor = Color3fromRGB(255, 255, 255),
        SkeletonTransparency = 0.7,
        SkeletonThickness = 1,
        SkeletonOutline = true,
        SkeletonOutlineColor = Color3fromRGB(0, 0, 0),
        SkeletonOutlineTransparency = 0.5,
        SkeletonStyle = "Line", -- "Line", "Dashed", "Dotted"
        SkeletonDashSize = 3, -- Size of dashes for dashed skeleton
        SkeletonDashGap = 2, -- Gap between dashes
        
        -- Head Dot
        HeadDotEnabled = true,
        HeadDotColor = Color3fromRGB(255, 0, 0),
        HeadDotTransparency = 0.7,
        HeadDotThickness = 1,
        HeadDotRadius = 3,
        HeadDotFilled = true,
        HeadDotOutline = true,
        HeadDotOutlineColor = Color3fromRGB(0, 0, 0),
        HeadDotOutlineTransparency = 0.5,
        HeadDotYOffset = 0, -- extra Y offset
        HeadDotXOffset = 0, -- extra X offset
        HeadDotPulse = false, -- Pulsing animation
        HeadDotPulseSpeed = 1, -- Speed of pulse
        HeadDotPulseSize = 1.5, -- Max size multiplier for pulse
        
        -- Tool ESP
        ToolEnabled = true,
        ToolColor = Color3fromRGB(255, 255, 255),
        ToolTransparency = 0.7,
        ToolOutline = true,
        ToolOutlineColor = Color3fromRGB(0, 0, 0),
        ToolOutlineTransparency = 0.5,
        ToolSize = 13,
        ToolFont = 2, -- Drawing.Fonts.UI
        ToolPosition = "bottom", -- top, bottom, left, right
        ToolYOffset = 30, -- extra Y offset
        ToolXOffset = 0, -- extra X offset
        ToolBackground = true,
        ToolBackgroundColor = Color3fromRGB(0, 0, 0),
        ToolBackgroundTransparency = 0.5,
        ToolBackgroundPadding = 2,
        
        -- State Display
        StateEnabled = true,
        StateColor = Color3fromRGB(255, 255, 255),
        StateTransparency = 0.7,
        StateOutline = true,
        StateOutlineColor = Color3fromRGB(0, 0, 0),
        StateOutlineTransparency = 0.5,
        StateSize = 13,
        StateFont = 2, -- Drawing.Fonts.UI
        StatePosition = "bottom", -- top, bottom, left, right
        StateYOffset = 45, -- extra Y offset
        StateXOffset = 0, -- extra X offset
        StateBackground = true,
        StateBackgroundColor = Color3fromRGB(0, 0, 0),
        StateBackgroundTransparency = 0.5,
        StateBackgroundPadding = 2,
        
        -- AimPoint
        AimPointEnabled = true,
        AimPointColor = Color3fromRGB(255, 0, 0),
        AimPointTransparency = 0.7,
        AimPointThickness = 1,
        AimPointRadius = 3,
        AimPointFilled = true,
        AimPointOutline = true,
        AimPointOutlineColor = Color3fromRGB(0, 0, 0),
        AimPointOutlineTransparency = 0.5,
        AimPointYOffset = 0, -- extra Y offset
        AimPointXOffset = 0, -- extra X offset
        AimPointPulse = true, -- Pulsing animation
        AimPointPulseSpeed = 1, -- Speed of abination
        AimPointPulseSize = 1.5, 
        
        -- Hitbox Markers
        HitboxEnabled = true,
        HitboxColor = Color3fromRGB(255, 0, 0),
        HitboxTransparency = 0.7,
        HitboxThickness = 1,
        UseCustomHitboxPoints = false,
        CustomHitboxPoints = {
            Head = true,
            Torso = true,
            Arms = true,
            Legs = true
        },
        
        
        TeamColor = true,
        EnemyColor = Color3fromRGB(255, 0, 0),
        TeamColorMode = "Team", -- "Team", "Custom"
        RainbowMode = false,
        RainbowSpeed = 1,
        
        -- keys
        ToggleKey = Enum.KeyCode.RightShift,
        BoxToggleKey = Enum.KeyCode.One,
        NameToggleKey = Enum.KeyCode.Two,
        DistanceToggleKey = Enum.KeyCode.Three,
        HealthToggleKey = Enum.KeyCode.Four,
        TracerToggleKey = Enum.KeyCode.Five,
        ChamsToggleKey = Enum.KeyCode.Six,
        SkeletonToggleKey = Enum.KeyCode.Seven,
        HeadDotToggleKey = Enum.KeyCode.Eight,
        
        
        Whitelist = {},
        Blacklist = {}
    },
    
    
    _rainbow = 0,
    _pulse = 0,
    _transitions = {}
}


function ESP:IsAlive(player)
    local character = player.Character
    local humanoid = character and FindFirstChild(character, "Humanoid")
    return character and humanoid and humanoid.Health > 0
end

function ESP:IsVisible(character, part)
    if not self.Settings.VisibilityCheck then return true end
    
    local origin = Camera.CFrame.Position
    local target = part.Position
    local direction = (target - origin).Unit * self.Settings.MaxDistance
    
    local raycastParams = RaycastParamsnew()
    raycastParams.FilterType = EnumRaycastFilterTypeBlacklist
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, character}
    
    local result = Workspace:Raycast(origin, direction, raycastParams)
    return result == nil
end

function ESP:GetTeam(player)
    return player.Team
end

function ESP:IsTeammate(player)
    if not self.Settings.TeamCheck then return false end
    
    local team = self:GetTeam(player)
    local localTeam = self:GetTeam(LocalPlayer)
    
    return team and localTeam and team == localTeam
end

function ESP:IsFriend(player)
    if not self.Settings.IgnoreFriends then return false end
    return LocalPlayer:IsFriendsWith(player.UserId)
end

function ESP:IsWhitelisted(player)
    return tablefind(self.Settings.Whitelist, player.Name) or tablefind(self.Settings.Whitelist, player.UserId)
end

function ESP:IsBlacklisted(player)
    return tablefind(self.Settings.Blacklist, player.Name) or tablefind(self.Settings.Blacklist, player.UserId)
end

function ESP:GetPlayerColor(player)
    if self.Settings.RainbowMode then
        return Color3fromHSV(self._rainbow, 1, 1)
    end
    
    if self:IsTeammate(player) then
        if self.Settings.TeamColorMode == "Team" and player.Team and player.Team.TeamColor then
            return player.Team.TeamColor.Color
        else
            return self.Settings.TeamColor and Color3fromRGB(0, 255, 0) or self.Settings.BoxColor
        end
    else
        return self.Settings.EnemyColor
    end
end

function ESP:GetDistance(position)
    return (Camera.CFrame.Position - position).Magnitude
end

function ESP:GetDistanceText(distance)
    if distance < 10 then
        return stringformat("%.1f m", distance)
    else
        return stringformat("%d m", mathfloor(distance))
    end
end

function ESP:CalculateTransparency(distance)
    if not self.Settings.FadeWithDistance then return 1 end
    
    local maxDistance = self.Settings.MaxDistance
    return mathclamp(1 - (distance / maxDistance), 0.1, 1)
end

function ESP:CalculateTextSize(distance)
    if not self.Settings.DistanceTextSize then return self.Settings.NameSize end
    
    local maxDistance = self.Settings.MaxDistance
    local minSize = 8
    local maxSize = self.Settings.NameSize
    
    return mathclamp(maxSize - (distance / maxDistance) * (maxSize - minSize), minSize, maxSize)
end

function ESP:WorldToScreen(position)
    local screenPosition, onScreen = WorldToViewportPoint(Camera, position)
    return Vector2new(screenPosition.X, screenPosition.Y), onScreen, screenPosition.Z
end


function ESP:Transition(id, current, target, speed)
    if not self.Settings.SmoothTransitions then return target end
    
    if not self._transitions[id] then
        self._transitions[id] = current
    end
    
    local transition = self._transitions[id]
    local delta = (target - transition) * (speed or self.Settings.TransitionSpeed)
    
    if mathabs(delta) < 0.01 then
        self._transitions[id] = target
    else
        self._transitions[id] = transition + delta
    end
    
    return self._transitions[id]
end


function ESP:CalculatePosition(positionType, boxCorners, basePosition, xOffset, yOffset)
    local position = basePosition
    
    if boxCorners then
        local topLeft = boxCorners.TopLeft
        local bottomRight = boxCorners.BottomRight
        local boxSize = bottomRight - topLeft
        local boxCenter = topLeft + (boxSize / 2)
        
        if positionType == "top" then
            position = Vector2new(boxCenter.X + xOffset, topLeft.Y + yOffset)
        elseif positionType == "bottom" then
            position = Vector2new(boxCenter.X + xOffset, bottomRight.Y + yOffset)
        elseif positionType == "left" then
            position = Vector2new(topLeft.X + xOffset, boxCenter.Y + yOffset)
        elseif positionType == "right" then
            position = Vector2new(bottomRight.X + xOffset, boxCenter.Y + yOffset)
        end
    else
       
        position = Vector2new(position.X + xOffset, position.Y + yOffset)
    end
    
    return position
end


function ESP:GetModelBounds(model)
    if not model then return nil end
    
    local parts = {}
    local success, _ = pcall(function()
        if model:IsA("Model") then
            parts = model:GetDescendants()
        else
            parts = {model}
        end
    end)
    
    if not success then return nil end
    
    local minX, minY, minZ = mathhuge, mathhuge, mathhuge
    local maxX, maxY, maxZ = -mathhuge, -mathhuge, -mathhuge
    
    local validParts = false
    
    for _, part in pairs(parts) do
        if part:IsA("BasePart") then
            validParts = true
            
            local cf = part.CFrame
            local size = part.Size
            local corners = {
                cf * CFramenew(-size.X/2, -size.Y/2, -size.Z/2),
                cf * CFramenew(-size.X/2, -size.Y/2, size.Z/2),
                cf * CFramenew(-size.X/2, size.Y/2, -size.Z/2),
                cf * CFramenew(-size.X/2, size.Y/2, size.Z/2),
                cf * CFramenew(size.X/2, -size.Y/2, -size.Z/2),
                cf * CFramenew(size.X/2, -size.Y/2, size.Z/2),
                cf * CFramenew(size.X/2, size.Y/2, -size.Z/2),
                cf * CFramenew(size.X/2, size.Y/2, size.Z/2)
            }
            
            for _, corner in pairs(corners) do
                local pos = corner.Position
                
                minX = mathmin(minX, pos.X)
                minY = mathmin(minY, pos.Y)
                minZ = mathmin(minZ, pos.Z)
                
                maxX = mathmax(maxX, pos.X)
                maxY = mathmax(maxY, pos.Y)
                maxZ = mathmax(maxZ, pos.Z)
            end
        end
    end
    
    if not validParts then return nil end
    
    local size = Vector3new(maxX - minX, maxY - minY, maxZ - minZ)
    local position = Vector3new(minX + size.X/2, minY + size.Y/2, minZ + size.Z/2)
    

    size = size + self.Settings.BoxPadding
    
    return {
        Size = size,
        Position = position
    }
end

function ESP:GetBoxCorners(object)
    local bounds
    
    if object:IsA("Model") or object:IsA("BasePart") then
        bounds = self:GetModelBounds(object)
        if not bounds then return nil end
    else
        return nil
    end
    
    local size = bounds.Size
    local position = bounds.Position
    
    local cf = CFramenew(position)
    
    local tl = cf * CFramenew(-size.X/2, size.Y/2, 0)
    local tr = cf * CFramenew(size.X/2, size.Y/2, 0)
    local bl = cf * CFramenew(-size.X/2, -size.Y/2, 0)
    local br = cf * CFramenew(size.X/2, -size.Y/2, 0)
    
    local tlp, tls, _ = self:WorldToScreen(tl.Position)
    local trp, trs, _ = self:WorldToScreen(tr.Position)
    local blp, bls, _ = self:WorldToScreen(bl.Position)
    local brp, brs, _ = self:WorldToScreen(br.Position)
    
    if not (tls and trs and bls and brs) then return nil end
    
    return {
        TopLeft = tlp,
        TopRight = trp,
        BottomLeft = blp,
        BottomRight = brp
    }
end

function ESP:Get3DBoxCorners(object)
    local bounds
    
    if object:IsA("Model") or object:IsA("BasePart") then
        bounds = self:GetModelBounds(object)
        if not bounds then return nil end
    else
        return nil
    end
    
    local size = bounds.Size
    local position = bounds.Position
    
    local cf = CFramenew(position)
    
    -- 3d box shits
    local corners = {
      
        cf * CFramenew(-size.X/2, size.Y/2, -size.Z/2),
        cf * CFramenew(size.X/2, size.Y/2, -size.Z/2),
        
        cf * CFramenew(-size.X/2, size.Y/2, size.Z/2),
        cf * CFramenew(size.X/2, size.Y/2, size.Z/2),
       
        cf * CFramenew(-size.X/2, -size.Y/2, -size.Z/2),
        cf * CFramenew(size.X/2, -size.Y/2, -size.Z/2),
       
        cf * CFramenew(-size.X/2, -size.Y/2, size.Z/2),
        cf * CFramenew(size.X/2, -size.Y/2, size.Z/2)
    }
    
    local screenCorners = {}
    local allOnScreen = true
    
    for i, corner in ipairs(corners) do
        local screenPosition, onScreen, _ = self:WorldToScreen(corner.Position)
        screenCorners[i] = screenPosition
        
        if not onScreen then
            allOnScreen = false
        end
    end
    
    if not allOnScreen then return nil end
    
    return screenCorners
end

function ESP:GetCornerBoxPoints(boxCorners)
    if not boxCorners then return nil end
    
    local topLeft = boxCorners.TopLeft
    local topRight = boxCorners.TopRight
    local bottomLeft = boxCorners.BottomLeft
    local bottomRight = boxCorners.BottomRight
    
    local width = (topRight - topLeft).Magnitude
    local height = (bottomLeft - topLeft).Magnitude
    local cornerSize = mathmin(self.Settings.CornerSize, width / 3, height / 3)
    
    local points = {
      
        {topLeft, topLeft + Vector2new(cornerSize, 0)}, 
        {topLeft, topLeft + Vector2new(0, cornerSize)}, 
        
        
        {topRight, topRight - Vector2new(cornerSize, 0)}, 
        {topRight, topRight + Vector2new(0, cornerSize)}, 
        
     
        {bottomLeft, bottomLeft + Vector2new(cornerSize, 0)}, 
        {bottomLeft, bottomLeft - Vector2new(0, cornerSize)}, 
        
       
        {bottomRight, bottomRight - Vector2new(cornerSize, 0)}, 
        {bottomRight, bottomRight - Vector2new(0, cornerSize)} 
    }
    
    return points
end

function ESP:GetSkeletonPoints(character)
    local points = {}
    local allOnScreen = true
    
    -- fire skeleton
    local connections = {
        {"Head", "Neck" or "UpperTorso" or "Torso"},
        {"Neck" or "UpperTorso" or "Torso", "UpperTorso" or "Torso"},
        {"UpperTorso" or "Torso", "LowerTorso" or "Torso"},
        {"LowerTorso" or "Torso", "RightUpperLeg" or "Right Leg"},
        {"LowerTorso" or "Torso", "LeftUpperLeg" or "Left Leg"},
        {"RightUpperLeg" or "Right Leg", "RightLowerLeg" or "Right Leg"},
        {"LeftUpperLeg" or "Left Leg", "LeftLowerLeg" or "Left Leg"},
        {"RightLowerLeg" or "Right Leg", "RightFoot" or "Right Leg"},
        {"LeftLowerLeg" or "Left Leg", "LeftFoot" or "Left Leg"},
        {"UpperTorso" or "Torso", "RightUpperArm" or "Right Arm"},
        {"UpperTorso" or "Torso", "LeftUpperArm" or "Left Arm"},
        {"RightUpperArm" or "Right Arm", "RightLowerArm" or "Right Arm"},
        {"LeftUpperArm" or "Left Arm", "LeftLowerArm" or "Left Arm"},
        {"RightLowerArm" or "Right Arm", "RightHand" or "Right Arm"},
        {"LeftLowerArm" or "Left Arm", "LeftHand" or "Left Arm"}
    }
    
    for _, connection in ipairs(connections) do
        local part1 = FindFirstChild(character, connection[1])
        local part2 = FindFirstChild(character, connection[2])
        
        if part1 and part2 then
            local p1, onScreen1, _ = self:WorldToScreen(part1.Position)
            local p2, onScreen2, _ = self:WorldToScreen(part2.Position)
            
            if onScreen1 and onScreen2 then
                tableinsert(points, {p1, p2})
            else
                allOnScreen = false
            end
        end
    end
    
    if not allOnScreen then return nil end
    
    return points
end

function ESP:GetHitboxPoints(character)
    local points = {}
    local allOnScreen = true
    
    local hitboxParts = {
        Head = FindFirstChild(character, "Head"),
        Torso = FindFirstChild(character, "UpperTorso") or FindFirstChild(character, "Torso"),
        Arms = {
            FindFirstChild(character, "RightUpperArm") or FindFirstChild(character, "Right Arm"),
            FindFirstChild(character, "LeftUpperArm") or FindFirstChild(character, "Left Arm")
        },
        Legs = {
            FindFirstChild(character, "RightUpperLeg") or FindFirstChild(character, "Right Leg"),
            FindFirstChild(character, "LeftUpperLeg") or FindFirstChild(character, "Left Leg")
        }
    }
    
    for partName, part in pairs(hitboxParts) do
        if self.Settings.CustomHitboxPoints[partName] then
            if type(part) == "table" then
                for _, p in ipairs(part) do
                    if p then
                        local screenPos, onScreen, _ = self:WorldToScreen(p.Position)
                        if onScreen then
                            tableinsert(points, screenPos)
                        else
                            allOnScreen = false
                        end
                    end
                end
            elseif part then
                local screenPos, onScreen, _ = self:WorldToScreen(part.Position)
                if onScreen then
                    tableinsert(points, screenPos)
                else
                    allOnScreen = false
                end
            end
        end
    end
    
    if not allOnScreen then return nil end
    
    return points
end


function ESP:IsCharacterInvisible(character)
    if not character then return false end
    
  
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Transparency < 0.9 then
            return false
        end
    end
    
    return true
end


function ESP:CreateDrawing(type, properties)
    local drawing = Drawingnew(type)
    
    for property, value in pairs(properties) do
        drawing[property] = value
    end
    
    tableinsert(self.Drawings, drawing)
    
    return drawing
end

function ESP:RemoveDrawing(drawing)
    if drawing then
        drawing:Remove()
        
        for i, d in ipairs(self.Drawings) do
            if d == drawing then
                tableremove(self.Drawings, i)
                break
            end
        end
    end
end

function ESP:ClearDrawings()
    for _, drawing in ipairs(self.Drawings) do
        drawing:Remove()
    end
    
    self.Drawings = {}
end


function ESP:CreateTextBackground(text, position, padding, color, transparency)
    local textBounds = text.TextBounds
    local background = self:CreateDrawing("Square", {
        Visible = text.Visible,
        Position = Vector2new(position.X - textBounds.X/2 - padding, position.Y - textBounds.Y/2 - padding),
        Size = Vector2new(textBounds.X + padding * 2, textBounds.Y + padding * 2),
        Color = color,
        Transparency = transparency,
        Filled = true,
        ZIndex = text.ZIndex - 1
    })
    
    return background
end


function ESP:DrawDashedLine(from, to, dashSize, gapSize, color, thickness, transparency, zIndex)
    local direction = (to - from).Unit
    local distance = (to - from).Magnitude
    local dashCount = mathfloor(distance / (dashSize + gapSize))
    local lines = {}
    
    for i = 0, dashCount do
        local startPos = from + direction * (i * (dashSize + gapSize))
        local endPos = startPos + direction * mathmin(dashSize, distance - i * (dashSize + gapSize))
        
        if (endPos - startPos).Magnitude > 0 then
            local line = self:CreateDrawing("Line", {
                Visible = true,
                From = startPos,
                To = endPos,
                Color = color,
                Thickness = thickness,
                Transparency = transparency,
                ZIndex = zIndex
            })
            
            tableinsert(lines, line)
        end
    end
    
    return lines
end


function ESP:CreatePlayerESP(player)
    if not player or player == LocalPlayer then return end
    
    local playerData = {
        Player = player,
        Drawings = {
            Box = self:CreateDrawing("Square", {
                Visible = false,
                Color = self.Settings.BoxColor,
                Thickness = self.Settings.BoxThickness,
                Transparency = self.Settings.BoxTransparency,
                Filled = self.Settings.BoxFilled,
                ZIndex = self.Settings.ZIndex
            }),
            BoxOutline = self:CreateDrawing("Square", {
                Visible = false,
                Color = self.Settings.BoxOutlineColor,
                Thickness = self.Settings.BoxThickness + 2,
                Transparency = self.Settings.BoxOutlineTransparency,
                Filled = false,
                ZIndex = self.Settings.ZIndex - 1
            }),
            BoxFill = self:CreateDrawing("Square", {
                Visible = false,
                Color = self.Settings.BoxColor,
                Transparency = self.Settings.BoxFilledTransparency,
                Filled = true,
                ZIndex = self.Settings.ZIndex - 2
            }),
            BoxCorners = {},
            Box3D = {},
            Name = self:CreateDrawing("Text", {
                Visible = false,
                Color = self.Settings.NameColor,
                Transparency = self.Settings.NameTransparency,
                Size = self.Settings.NameSize,
                Center = true,
                Outline = self.Settings.NameOutline,
                OutlineColor = self.Settings.NameOutlineColor,
                Font = self.Settings.NameFont,
                ZIndex = self.Settings.ZIndex
            }),
            NameBackground = self:CreateDrawing("Square", {
                Visible = false,
                Color = self.Settings.NameBackgroundColor,
                Transparency = self.Settings.NameBackgroundTransparency,
                Filled = true,
                ZIndex = self.Settings.ZIndex - 1
            }),
            Distance = self:CreateDrawing("Text", {
                Visible = false,
                Color = self.Settings.DistanceColor,
                Transparency = self.Settings.DistanceTransparency,
                Size = self.Settings.DistanceSize,
                Center = true,
                Outline = self.Settings.DistanceOutline,
                OutlineColor = self.Settings.DistanceOutlineColor,
                Font = self.Settings.DistanceFont,
                ZIndex = self.Settings.ZIndex
            }),
            DistanceBackground = self:CreateDrawing("Square", {
                Visible = false,
                Color = self.Settings.DistanceBackgroundColor,
                Transparency = self.Settings.DistanceBackgroundTransparency,
                Filled = true,
                ZIndex = self.Settings.ZIndex - 1
            }),
            HealthBar = self:CreateDrawing("Square", {
                Visible = false,
                Color = self.Settings.HealthColor,
                Thickness = self.Settings.HealthThickness,
                Transparency = self.Settings.HealthTransparency,
                Filled = true,
                ZIndex = self.Settings.ZIndex
            }),
            HealthBarOutline = self:CreateDrawing("Square", {
                Visible = false,
                Color = self.Settings.HealthOutlineColor,
                Thickness = 1,
                Transparency = self.Settings.HealthOutlineTransparency,
                Filled = false,
                ZIndex = self.Settings.ZIndex - 1
            }),
            HealthBarBackground = self:CreateDrawing("Square", {
                Visible = false,
                Color = self.Settings.HealthBackgroundColor,
                Transparency = self.Settings.HealthBackgroundTransparency,
                Filled = true,
                ZIndex = self.Settings.ZIndex - 2
            }),
            Tracer = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.TracerColor,
                Thickness = self.Settings.TracerThickness,
                Transparency = self.Settings.TracerTransparency,
                ZIndex = self.Settings.ZIndex
            }),
            TracerOutline = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.TracerOutlineColor,
                Thickness = self.Settings.TracerThickness + 2,
                Transparency = self.Settings.TracerOutlineTransparency,
                ZIndex = self.Settings.ZIndex - 1
            }),
            TracerDashed = {},
            HeadDot = self:CreateDrawing("Circle", {
                Visible = false,
                Color = self.Settings.HeadDotColor,
                Thickness = self.Settings.HeadDotThickness,
                Transparency = self.Settings.HeadDotTransparency,
                NumSides = 30,
                Filled = self.Settings.HeadDotFilled,
                Radius = self.Settings.HeadDotRadius,
                ZIndex = self.Settings.ZIndex
            }),
            HeadDotOutline = self:CreateDrawing("Circle", {
                Visible = false,
                Color = self.Settings.HeadDotOutlineColor,
                Thickness = self.Settings.HeadDotThickness + 2,
                Transparency = self.Settings.HeadDotOutlineTransparency,
                NumSides = 30,
                Filled = false,
                Radius = self.Settings.HeadDotRadius,
                ZIndex = self.Settings.ZIndex - 1
            }),
            Tool = self:CreateDrawing("Text", {
                Visible = false,
                Color = self.Settings.ToolColor,
                Transparency = self.Settings.ToolTransparency,
                Size = self.Settings.ToolSize,
                Center = true,
                Outline = self.Settings.ToolOutline,
                OutlineColor = self.Settings.ToolOutlineColor,
                Font = self.Settings.ToolFont,
                ZIndex = self.Settings.ZIndex
            }),
            ToolBackground = self:CreateDrawing("Square", {
                Visible = false,
                Color = self.Settings.ToolBackgroundColor,
                Transparency = self.Settings.ToolBackgroundTransparency,
                Filled = true,
                ZIndex = self.Settings.ZIndex - 1
            }),
            State = self:CreateDrawing("Text", {
                Visible = false,
                Color = self.Settings.StateColor,
                Transparency = self.Settings.StateTransparency,
                Size = self.Settings.StateSize,
                Center = true,
                Outline = self.Settings.StateOutline,
                OutlineColor = self.Settings.StateOutlineColor,
                Font = self.Settings.StateFont,
                ZIndex = self.Settings.ZIndex
            }),
            StateBackground = self:CreateDrawing("Square", {
                Visible = false,
                Color = self.Settings.StateBackgroundColor,
                Transparency = self.Settings.StateBackgroundTransparency,
                Filled = true,
                ZIndex = self.Settings.ZIndex - 1
            }),
            AimPoint = self:CreateDrawing("Circle", {
                Visible = false,
                Color = self.Settings.AimPointColor,
                Thickness = self.Settings.AimPointThickness,
                Transparency = self.Settings.AimPointTransparency,
                NumSides = 30,
                Filled = self.Settings.AimPointFilled,
                Radius = self.Settings.AimPointRadius,
                ZIndex = self.Settings.ZIndex
            }),
            AimPointOutline = self:CreateDrawing("Circle", {
                Visible = false,
                Color = self.Settings.AimPointOutlineColor,
                Thickness = self.Settings.AimPointThickness + 2,
                Transparency = self.Settings.AimPointOutlineTransparency,
                NumSides = 30,
                Filled = false,
                Radius = self.Settings.AimPointRadius,
                ZIndex = self.Settings.ZIndex - 1
            }),
            Skeleton = {},
            SkeletonDashed = {},
            Hitbox = {}
        }
    }
    
 
    for i = 1, 8 do
        playerData.Drawings.BoxCorners[i] = {
            Line = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.BoxColor,
                Thickness = self.Settings.BoxThickness,
                Transparency = self.Settings.BoxTransparency,
                ZIndex = self.Settings.ZIndex
            }),
            Outline = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.BoxOutlineColor,
                Thickness = self.Settings.BoxThickness + 2,
                Transparency = self.Settings.BoxOutlineTransparency,
                ZIndex = self.Settings.ZIndex - 1
            })
        }
    end
    
    
    for i = 1, 12 do
        playerData.Drawings.Box3D[i] = {
            Line = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.BoxColor,
                Thickness = self.Settings.BoxThickness,
                Transparency = self.Settings.BoxTransparency,
                ZIndex = self.Settings.ZIndex
            }),
            Outline = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.BoxOutlineColor,
                Thickness = self.Settings.BoxThickness + 2,
                Transparency = self.Settings.BoxOutlineTransparency,
                ZIndex = self.Settings.ZIndex - 1
            })
        }
    end
    
  
    for i = 1, 15 do
        playerData.Drawings.Skeleton[i] = {
            Line = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.SkeletonColor,
                Thickness = self.Settings.SkeletonThickness,
                Transparency = self.Settings.SkeletonTransparency,
                ZIndex = self.Settings.ZIndex
            }),
            Outline = self:CreateDrawing("Line", {
                Visible = false,
                Color = self.Settings.SkeletonOutlineColor,
                Thickness = self.Settings.SkeletonThickness + 2,
                Transparency = self.Settings.SkeletonOutlineTransparency,
                ZIndex = self.Settings.ZIndex - 1
            })
        }
    end
    

    for i = 1, 10 do
        playerData.Drawings.Hitbox[i] = self:CreateDrawing("Circle", {
            Visible = false,
            Color = self.Settings.HitboxColor,
            Thickness = self.Settings.HitboxThickness,
            Transparency = self.Settings.HitboxTransparency,
            NumSides = 30,
            Filled = true,
            Radius = 2,
            ZIndex = self.Settings.ZIndex
        })
    end
    
    self.Players[player] = playerData
    return playerData
end

function ESP:RemovePlayerESP(player)
    local playerData = self.Players[player]
    
    if playerData then
        for _, drawing in pairs(playerData.Drawings) do
            if type(drawing) == "table" then
                if drawing.Line then
                    self:RemoveDrawing(drawing.Line)
                    self:RemoveDrawing(drawing.Outline)
                else
                    for _, subDrawing in pairs(drawing) do
                        if type(subDrawing) == "table" then
                            self:RemoveDrawing(subDrawing.Line)
                            self:RemoveDrawing(subDrawing.Outline)
                        else
                            self:RemoveDrawing(subDrawing)
                        end
                    end
                end
            else
                self:RemoveDrawing(drawing)
            end
        end
        
        self.Players[player] = nil
    end
end

function ESP:UpdatePlayerESP(player)
    local playerData = self.Players[player]
    if not playerData then return end
    
    local character = player.Character
    if not character then return end
    
    local humanoid = FindFirstChild(character, "Humanoid")
    local hrp = FindFirstChild(character, "HumanoidRootPart")
    local head = FindFirstChild(character, "Head")
    
    if not (humanoid and hrp and head) then return end
    
   
    if self.Settings.IgnoreDead and humanoid.Health <= 0 then return end
    if self.Settings.IgnoreInvisible and self:IsCharacterInvisible(character) then return end
    if self:IsBlacklisted(player) then return end
    if self.Settings.Whitelist and #self.Settings.Whitelist > 0 and not self:IsWhitelisted(player) then return end
    if self:IsFriend(player) then return end
    
 
    local position = hrp.Position
    local distance = self:GetDistance(position)
    
    if distance > self.Settings.MaxDistance then
        for _, drawing in pairs(playerData.Drawings) do
            if type(drawing) == "table" then
                if drawing.Line then
                    drawing.Line.Visible = false
                    drawing.Outline.Visible = false
                else
                    for _, subDrawing in pairs(drawing) do
                        if type(subDrawing) == "table" then
                            subDrawing.Line.Visible = false
                            subDrawing.Outline.Visible = false
                        else
                            subDrawing.Visible = false
                        end
                    end
                end
            else
                drawing.Visible = false
            end
        end
        return
    end
    
  
    local isVisible = self:IsVisible(character, head)
    local transparency = self:CalculateTransparency(distance)
    if self.Settings.VisibilityFade and not isVisible then
        transparency = transparency * 0.5
    end
    
 
    local color = self:GetPlayerColor(player)
    
   
    if self.Settings.BoxEnabled then
        local boxCorners = self:GetBoxCorners(character)
        
       
        playerData.Drawings.Box.Visible = false
        playerData.Drawings.BoxOutline.Visible = false
        playerData.Drawings.BoxFill.Visible = false
        
        for _, corner in pairs(playerData.Drawings.BoxCorners) do
            corner.Line.Visible = false
            corner.Outline.Visible = false
        end
        
        for _, line in pairs(playerData.Drawings.Box3D) do
            line.Line.Visible = false
            line.Outline.Visible = false
        end
        
        if boxCorners then
            local topLeft = boxCorners.TopLeft
            local bottomRight = boxCorners.BottomRight
            local boxSize = bottomRight - topLeft
            
            if self.Settings.BoxType == "2D" then
                playerData.Drawings.Box.Position = topLeft
                playerData.Drawings.Box.Size = boxSize
                playerData.Drawings.Box.Color = color
                playerData.Drawings.Box.Transparency = transparency * self.Settings.BoxTransparency
                playerData.Drawings.Box.Visible = true
                
                if self.Settings.BoxOutline then
                    playerData.Drawings.BoxOutline.Position = topLeft
                    playerData.Drawings.BoxOutline.Size = boxSize
                    playerData.Drawings.BoxOutline.Transparency = transparency * self.Settings.BoxOutlineTransparency
                    playerData.Drawings.BoxOutline.Visible = true
                end
                
                if self.Settings.BoxFilled then
                    playerData.Drawings.BoxFill.Position = topLeft
                    playerData.Drawings.BoxFill.Size = boxSize
                    playerData.Drawings.BoxFill.Color = color
                    playerData.Drawings.BoxFill.Transparency = transparency * self.Settings.BoxFilledTransparency
                    playerData.Drawings.BoxFill.Visible = true
                end
            elseif self.Settings.BoxType == "Corner" then
                local cornerPoints = self:GetCornerBoxPoints(boxCorners)
                
                if cornerPoints then
                    for i, points in ipairs(cornerPoints) do
                        if i <= #playerData.Drawings.BoxCorners then
                            playerData.Drawings.BoxCorners[i].Line.From = points[1]
                            playerData.Drawings.BoxCorners[i].Line.To = points[2]
                            playerData.Drawings.BoxCorners[i].Line.Color = color
                            playerData.Drawings.BoxCorners[i].Line.Transparency = transparency * self.Settings.BoxTransparency
                            playerData.Drawings.BoxCorners[i].Line.Visible = true
                            
                            if self.Settings.BoxOutline then
                                playerData.Drawings.BoxCorners[i].Outline.From = points[1]
                                playerData.Drawings.BoxCorners[i].Outline.To = points[2]
                                playerData.Drawings.BoxCorners[i].Outline.Transparency = transparency * self.Settings.BoxOutlineTransparency
                                playerData.Drawings.BoxCorners[i].Outline.Visible = true
                            end
                        end
                    end
                end
            elseif self.Settings.BoxType == "3D" then
                local corners3D = self:Get3DBoxCorners(character)
                
                if corners3D then
                  
                    local edges = {
                      
                        {1, 2}, {2, 4}, {4, 3}, {3, 1},
                        
                        {5, 6}, {6, 8}, {8, 7}, {7, 5},
                    
                        {1, 5}, {2, 6}, {3, 7}, {4, 8}
                    }
                    
                    for i, edge in ipairs(edges) do
                        if i <= #playerData.Drawings.Box3D then
                            playerData.Drawings.Box3D[i].Line.From = corners3D[edge[1]]
                            playerData.Drawings.Box3D[i].Line.To = corners3D[edge[2]]
                            playerData.Drawings.Box3D[i].Line.Color = color
                            playerData.Drawings.Box3D[i].Line.Transparency = transparency * self.Settings.BoxTransparency
                            playerData.Drawings.Box3D[i].Line.Visible = true
                            
                            if self.Settings.BoxOutline then
                                playerData.Drawings.Box3D[i].Outline.From = corners3D[edge[1]]
                                playerData.Drawings.Box3D[i].Outline.To = corners3D[edge[2]]
                                playerData.Drawings.Box3D[i].Outline.Transparency = transparency * self.Settings.BoxOutlineTransparency
                                playerData.Drawings.Box3D[i].Outline.Visible = true
                            end
                        end
                    end
                end
            end
        end
    else
        playerData.Drawings.Box.Visible = false
        playerData.Drawings.BoxOutline.Visible = false
        playerData.Drawings.BoxFill.Visible = false
        
        for _, corner in pairs(playerData.Drawings.BoxCorners) do
            corner.Line.Visible = false
            corner.Outline.Visible = false
        end
        
        for _, line in pairs(playerData.Drawings.Box3D) do
            line.Line.Visible = false
            line.Outline.Visible = false
        end
    end
    
  
    if self.Settings.NameEnabled then
        local headPos, onScreen, depth = self:WorldToScreen(head.Position)
        local boxCorners = self:GetBoxCorners(character)
        
        if onScreen then
            local displayName = self.Settings.UseDisplayName and player.DisplayName or player.Name
            local textSize = self:CalculateTextSize(distance)
            local namePosition = self:CalculatePosition(
                self.Settings.NamePosition, 
                boxCorners, 
                headPos, 
                self.Settings.NameXOffset, 
                self.Settings.NameYOffset
            )
            
            playerData.Drawings.Name.Position = namePosition
            playerData.Drawings.Name.Text = displayName
            playerData.Drawings.Name.Color = color
            playerData.Drawings.Name.Transparency = transparency * self.Settings.NameTransparency
            playerData.Drawings.Name.Size = textSize
            playerData.Drawings.Name.Visible = true
            
            if self.Settings.NameBackground then
                local textBounds = playerData.Drawings.Name.TextBounds
                playerData.Drawings.NameBackground.Position = Vector2new(
                    namePosition.X - textBounds.X/2 - self.Settings.NameBackgroundPadding,
                    namePosition.Y - textBounds.Y/2 - self.Settings.NameBackgroundPadding
                )
                playerData.Drawings.NameBackground.Size = Vector2new(
                    textBounds.X + self.Settings.NameBackgroundPadding * 2,
                    textBounds.Y + self.Settings.NameBackgroundPadding * 2
                )
                playerData.Drawings.NameBackground.Transparency = transparency * self.Settings.NameBackgroundTransparency
                playerData.Drawings.NameBackground.Visible = true
            else
                playerData.Drawings.NameBackground.Visible = false
            end
        else
            playerData.Drawings.Name.Visible = false
            playerData.Drawings.NameBackground.Visible = false
        end
    else
        playerData.Drawings.Name.Visible = false
        playerData.Drawings.NameBackground.Visible = false
    end
    

    if self.Settings.DistanceEnabled then
        local headPos, onScreen, depth = self:WorldToScreen(head.Position)
        local boxCorners = self:GetBoxCorners(character)
        
        if onScreen then
            local distanceText = self:GetDistanceText(distance)
            local textSize = self:CalculateTextSize(distance)
            local distancePosition = self:CalculatePosition(
                self.Settings.DistancePosition, 
                boxCorners, 
                headPos, 
                self.Settings.DistanceXOffset, 
                self.Settings.DistanceYOffset
            )
            
            playerData.Drawings.Distance.Position = distancePosition
            playerData.Drawings.Distance.Text = distanceText
            playerData.Drawings.Distance.Color = color
            playerData.Drawings.Distance.Transparency = transparency * self.Settings.DistanceTransparency
            playerData.Drawings.Distance.Size = textSize
            playerData.Drawings.Distance.Visible = true
            
            if self.Settings.DistanceBackground then
                local textBounds = playerData.Drawings.Distance.TextBounds
                playerData.Drawings.DistanceBackground.Position = Vector2new(
                    distancePosition.X - textBounds.X/2 - self.Settings.DistanceBackgroundPadding,
                    distancePosition.Y - textBounds.Y/2 - self.Settings.DistanceBackgroundPadding
                )
                playerData.Drawings.DistanceBackground.Size = Vector2new(
                    textBounds.X + self.Settings.DistanceBackgroundPadding * 2,
                    textBounds.Y + self.Settings.DistanceBackgroundPadding * 2
                )
                playerData.Drawings.DistanceBackground.Transparency = transparency * self.Settings.DistanceBackgroundTransparency
                playerData.Drawings.DistanceBackground.Visible = true
            else
                playerData.Drawings.DistanceBackground.Visible = false
            end
        else
            playerData.Drawings.Distance.Visible = false
            playerData.Drawings.DistanceBackground.Visible = false
        end
    else
        playerData.Drawings.Distance.Visible = false
        playerData.Drawings.DistanceBackground.Visible = false
    end
    
    
    if self.Settings.HealthEnabled then
        local boxCorners = self:GetBoxCorners(character)
        
        if boxCorners and humanoid then
            local topLeft = boxCorners.TopLeft
            local bottomRight = boxCorners.BottomRight
            local boxSize = bottomRight - topLeft
            
            local healthPercent = mathclamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
            local healthColor
            
            if self.Settings.HealthGradient then
                healthColor = Color3fromRGB(
                    255 * (1 - healthPercent),
                    255 * healthPercent,
                    0
                )
            else
                healthColor = self.Settings.HealthColor
            end
            
            if self.Settings.HealthType == "Vertical" then
                local barHeight = boxSize.Y * healthPercent
                local barWidth = self.Settings.HealthBarThickness
                local healthPosition
                local backgroundPosition
                
                if self.Settings.HealthPosition == "left" then
                    healthPosition = Vector2new(
                        topLeft.X + self.Settings.HealthXOffset - barWidth,
                        bottomRight.Y - barHeight + self.Settings.HealthYOffset
                    )
                    
                    backgroundPosition = Vector2new(
                        topLeft.X + self.Settings.HealthXOffset - barWidth,
                        topLeft.Y + self.Settings.HealthYOffset
                    )
                elseif self.Settings.HealthPosition == "right" then
                    healthPosition = Vector2new(
                        bottomRight.X + self.Settings.HealthXOffset,
                        bottomRight.Y - barHeight + self.Settings.HealthYOffset
                    )
                    
                    backgroundPosition = Vector2new(
                        bottomRight.X + self.Settings.HealthXOffset,
                        topLeft.Y + self.Settings.HealthYOffset
                    )
                else
                    healthPosition = Vector2new(
                        topLeft.X + self.Settings.HealthXOffset - barWidth,
                        bottomRight.Y - barHeight + self.Settings.HealthYOffset
                    )
                    
                    backgroundPosition = Vector2new(
                        topLeft.X + self.Settings.HealthXOffset - barWidth,
                        topLeft.Y + self.Settings.HealthYOffset
                    )
                end
                
                playerData.Drawings.HealthBar.Position = healthPosition
                playerData.Drawings.HealthBar.Size = Vector2new(barWidth, barHeight)
                playerData.Drawings.HealthBarOutline.Position = backgroundPosition
                playerData.Drawings.HealthBarOutline.Size = Vector2new(barWidth, boxSize.Y)
                
                if self.Settings.HealthBackground then
                    playerData.Drawings.HealthBarBackground.Position = backgroundPosition
                    playerData.Drawings.HealthBarBackground.Size = Vector2new(barWidth, boxSize.Y)
                    playerData.Drawings.HealthBarBackground.Transparency = transparency * self.Settings.HealthBackgroundTransparency
                    playerData.Drawings.HealthBarBackground.Visible = true
                else
                    playerData.Drawings.HealthBarBackground.Visible = false
                end
            else 
                local barWidth = boxSize.X * healthPercent
                local barHeight = self.Settings.HealthBarThickness
                local healthPosition
                local backgroundPosition
                
                if self.Settings.HealthPosition == "top" then
                    healthPosition = Vector2new(
                        topLeft.X + self.Settings.HealthXOffset,
                        topLeft.Y + self.Settings.HealthYOffset - barHeight
                    )
                    
                    backgroundPosition = Vector2new(
                        topLeft.X + self.Settings.HealthXOffset,
                        topLeft.Y + self.Settings.HealthYOffset - barHeight
                    )
                elseif self.Settings.HealthPosition == "bottom" then
                    healthPosition = Vector2new(
                        topLeft.X + self.Settings.HealthXOffset,
                        bottomRight.Y + self.Settings.HealthYOffset
                    )
                    
                    backgroundPosition = Vector2new(
                        topLeft.X + self.Settings.HealthXOffset,
                        bottomRight.Y + self.Settings.HealthYOffset
                    )
                else
                    healthPosition = Vector2new(
                        topLeft.X + self.Settings.HealthXOffset,
                        bottomRight.Y + self.Settings.HealthYOffset
                    )
                    
                    backgroundPosition = Vector2new(
                        topLeft.X + self.Settings.HealthXOffset,
                        bottomRight.Y + self.Settings.HealthYOffset
                    )
                end
                
                playerData.Drawings.HealthBar.Position = healthPosition
                playerData.Drawings.HealthBar.Size = Vector2new(barWidth, barHeight)
                playerData.Drawings.HealthBarOutline.Position = backgroundPosition
                playerData.Drawings.HealthBarOutline.Size = Vector2new(boxSize.X, barHeight)
                
                if self.Settings.HealthBackground then
                    playerData.Drawings.HealthBarBackground.Position = backgroundPosition
                    playerData.Drawings.HealthBarBackground.Size = Vector2new(boxSize.X, barHeight)
                    playerData.Drawings.HealthBarBackground.Transparency = transparency * self.Settings.HealthBackgroundTransparency
                    playerData.Drawings.HealthBarBackground.Visible = true
                else
                    playerData.Drawings.HealthBarBackground.Visible = false
                end
            end
            
            playerData.Drawings.HealthBar.Color = healthColor
            playerData.Drawings.HealthBar.Transparency = transparency * self.Settings.HealthTransparency
            playerData.Drawings.HealthBar.Visible = true
            
            if self.Settings.HealthOutline then
                playerData.Drawings.HealthBarOutline.Transparency = transparency * self.Settings.HealthOutlineTransparency
                playerData.Drawings.HealthBarOutline.Visible = true
            else
                playerData.Drawings.HealthBarOutline.Visible = false
            end
        else
            playerData.Drawings.HealthBar.Visible = false
            playerData.Drawings.HealthBarOutline.Visible = false
            playerData.Drawings.HealthBarBackground.Visible = false
        end
    else
        playerData.Drawings.HealthBar.Visible = false
        playerData.Drawings.HealthBarOutline.Visible = false
        playerData.Drawings.HealthBarBackground.Visible = false
    end
    
 
    if self.Settings.TracerEnabled then
        local hrpPos, onScreen, depth = self:WorldToScreen(hrp.Position)
        
        if onScreen then
            local from
            
            if self.Settings.TracerOrigin == "Bottom" then
                from = Vector2new(Camera.ViewportSize.X / 2 + self.Settings.TracerXOffset, Camera.ViewportSize.Y + self.Settings.TracerYOffset)
            elseif self.Settings.TracerOrigin == "Center" then
                from = Vector2new(Camera.ViewportSize.X / 2 + self.Settings.TracerXOffset, Camera.ViewportSize.Y / 2 + self.Settings.TracerYOffset)
            elseif self.Settings.TracerOrigin == "Mouse" then
                from = UserInputService:GetMouseLocation() + Vector2new(self.Settings.TracerXOffset, self.Settings.TracerYOffset)
            end
            
          
            for _, line in pairs(playerData.Drawings.TracerDashed) do
                self:RemoveDrawing(line)
            end
            playerData.Drawings.TracerDashed = {}
            
            if self.Settings.TracerStyle == "Line" then
                playerData.Drawings.Tracer.From = from
                playerData.Drawings.Tracer.To = hrpPos
                playerData.Drawings.Tracer.Color = color
                playerData.Drawings.Tracer.Transparency = transparency * self.Settings.TracerTransparency
                playerData.Drawings.Tracer.Visible = true
                
                if self.Settings.TracerOutline then
                    playerData.Drawings.TracerOutline.From = from
                    playerData.Drawings.TracerOutline.To = hrpPos
                    playerData.Drawings.TracerOutline.Transparency = transparency * self.Settings.TracerOutlineTransparency
                    playerData.Drawings.TracerOutline.Visible = true
                else
                    playerData.Drawings.TracerOutline.Visible = false
                end
            elseif self.Settings.TracerStyle == "Dashed" or self.Settings.TracerStyle == "Dotted" then
                playerData.Drawings.Tracer.Visible = false
                playerData.Drawings.TracerOutline.Visible = false
                
                local dashSize = self.Settings.TracerStyle == "Dotted" and 1 or self.Settings.TracerDashSize
                local gapSize = self.Settings.TracerDashGap
                
                playerData.Drawings.TracerDashed = self:DrawDashedLine(
                    from, 
                    hrpPos, 
                    dashSize, 
                    gapSize, 
                    color, 
                    self.Settings.TracerThickness, 
                    transparency * self.Settings.TracerTransparency, 
                    self.Settings.ZIndex
                )
            end
        else
            playerData.Drawings.Tracer.Visible = false
            playerData.Drawings.TracerOutline.Visible = false
            
            for _, line in pairs(playerData.Drawings.TracerDashed) do
                line.Visible = false
            end
        end
    else
        playerData.Drawings.Tracer.Visible = false
        playerData.Drawings.TracerOutline.Visible = false
        
        for _, line in pairs(playerData.Drawings.TracerDashed) do
            line.Visible = false
        end
    end
    
  
    if self.Settings.HeadDotEnabled then
        local headPos, onScreen, depth = self:WorldToScreen(head.Position)
        
        if onScreen then
            local headDotPosition = Vector2new(
                headPos.X + self.Settings.HeadDotXOffset,
                headPos.Y + self.Settings.HeadDotYOffset
            )
            
            local radius = self.Settings.HeadDotRadius
            
            if self.Settings.HeadDotPulse then
                local pulse = (mathsin(self._pulse * self.Settings.HeadDotPulseSpeed) + 1) / 2
                radius = radius * (1 + pulse * (self.Settings.HeadDotPulseSize - 1))
            end
            
            playerData.Drawings.HeadDot.Position = headDotPosition
            playerData.Drawings.HeadDot.Color = color
            playerData.Drawings.HeadDot.Transparency = transparency * self.Settings.HeadDotTransparency
            playerData.Drawings.HeadDot.Radius = radius
            playerData.Drawings.HeadDot.Visible = true
            
            if self.Settings.HeadDotOutline then
                playerData.Drawings.HeadDotOutline.Position = headDotPosition
                playerData.Drawings.HeadDotOutline.Transparency = transparency * self.Settings.HeadDotOutlineTransparency
                playerData.Drawings.HeadDotOutline.Radius = radius
                playerData.Drawings.HeadDotOutline.Visible = true
            else
                playerData.Drawings.HeadDotOutline.Visible = false
            end
        else
            playerData.Drawings.HeadDot.Visible = false
            playerData.Drawings.HeadDotOutline.Visible = false
        end
    else
        playerData.Drawings.HeadDot.Visible = false
        playerData.Drawings.HeadDotOutline.Visible = false
    end
    
 
    if self.Settings.ToolEnabled then
        local headPos, onScreen, depth = self:WorldToScreen(head.Position)
        local boxCorners = self:GetBoxCorners(character)
        
        if onScreen then
            local tool = character:FindFirstChildOfClass("Tool")
            local toolName = tool and tool.Name or "None"
            local toolPosition = self:CalculatePosition(
                self.Settings.ToolPosition, 
                boxCorners, 
                headPos, 
                self.Settings.ToolXOffset, 
                self.Settings.ToolYOffset
            )
            
            playerData.Drawings.Tool.Position = toolPosition
            playerData.Drawings.Tool.Text = "Tool: " .. toolName
            playerData.Drawings.Tool.Color = color
            playerData.Drawings.Tool.Transparency = transparency * self.Settings.ToolTransparency
            playerData.Drawings.Tool.Visible = true
            
            if self.Settings.ToolBackground then
                local textBounds = playerData.Drawings.Tool.TextBounds
                playerData.Drawings.ToolBackground.Position = Vector2new(
                    toolPosition.X - textBounds.X/2 - self.Settings.ToolBackgroundPadding,
                    toolPosition.Y - textBounds.Y/2 - self.Settings.ToolBackgroundPadding
                )
                playerData.Drawings.ToolBackground.Size = Vector2new(
                    textBounds.X + self.Settings.ToolBackgroundPadding * 2,
                    textBounds.Y + self.Settings.ToolBackgroundPadding * 2
                )
                playerData.Drawings.ToolBackground.Transparency = transparency * self.Settings.ToolBackgroundTransparency
                playerData.Drawings.ToolBackground.Visible = true
            else
                playerData.Drawings.ToolBackground.Visible = false
            end
        else
            playerData.Drawings.Tool.Visible = false
            playerData.Drawings.ToolBackground.Visible = false
        end
    else
        playerData.Drawings.Tool.Visible = false
        playerData.Drawings.ToolBackground.Visible = false
    end
    
   
    if self.Settings.StateEnabled then
        local headPos, onScreen, depth = self:WorldToScreen(head.Position)
        local boxCorners = self:GetBoxCorners(character)
        
        if onScreen then
            local state = "Standing"
            
            if humanoid.Health <= 0 then
                state = "Dead"
            elseif humanoid.PlatformStand then
                state = "Stunned"
            elseif humanoid:GetState() == Enum.HumanoidStateType.Climbing then
                state = "Climbing"
            elseif humanoid:GetState() == Enum.HumanoidStateType.Jumping then
                state = "Jumping"
            elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                state = "Falling"
            elseif humanoid:GetState() == Enum.HumanoidStateType.Seated then
                state = "Seated"
            elseif humanoid:GetState() == Enum.HumanoidStateType.Swimming then
                state = "Swimming"
            elseif humanoid.MoveDirection.Magnitude > 0 then
                state = "Moving"
            end
            
            local statePosition = self:CalculatePosition(
                self.Settings.StatePosition, 
                boxCorners, 
                headPos, 
                self.Settings.StateXOffset, 
                self.Settings.StateYOffset
            )
            
            playerData.Drawings.State.Position = statePosition
            playerData.Drawings.State.Text = "State: " .. state
            playerData.Drawings.State.Color = color
            playerData.Drawings.State.Transparency = transparency * self.Settings.StateTransparency
            playerData.Drawings.State.Visible = true
            
            if self.Settings.StateBackground then
                local textBounds = playerData.Drawings.State.TextBounds
                playerData.Drawings.StateBackground.Position = Vector2new(
                    statePosition.X - textBounds.X/2 - self.Settings.StateBackgroundPadding,
                    statePosition.Y - textBounds.Y/2 - self.Settings.StateBackgroundPadding
                )
                playerData.Drawings.StateBackground.Size = Vector2new(
                    textBounds.X + self.Settings.StateBackgroundPadding * 2,
                    textBounds.Y + self.Settings.StateBackgroundPadding * 2
                )
                playerData.Drawings.StateBackground.Transparency = transparency * self.Settings.StateBackgroundTransparency
                playerData.Drawings.StateBackground.Visible = true
            else
                playerData.Drawings.StateBackground.Visible = false
            end
        else
            playerData.Drawings.State.Visible = false
            playerData.Drawings.StateBackground.Visible = false
        end
    else
        playerData.Drawings.State.Visible = false
        playerData.Drawings.StateBackground.Visible = false
    end
    
 
    if self.Settings.AimPointEnabled then
        local aimPart = FindFirstChild(character, "Head") or FindFirstChild(character, "HumanoidRootPart")
        
        if aimPart then
            local aimPos, onScreen, depth = self:WorldToScreen(aimPart.Position)
            
            if onScreen then
                local aimPointPosition = Vector2new(
                    aimPos.X + self.Settings.AimPointXOffset,
                    aimPos.Y + self.Settings.AimPointYOffset
                )
                
                local radius = self.Settings.AimPointRadius
                
                if self.Settings.AimPointPulse then
                    local pulse = (mathsin(self._pulse * self.Settings.AimPointPulseSpeed) + 1) / 2
                    radius = radius * (1 + pulse * (self.Settings.AimPointPulseSize - 1))
                end
                
                playerData.Drawings.AimPoint.Position = aimPointPosition
                playerData.Drawings.AimPoint.Color = color
                playerData.Drawings.AimPoint.Transparency = transparency * self.Settings.AimPointTransparency
                playerData.Drawings.AimPoint.Radius = radius
                playerData.Drawings.AimPoint.Visible = true
                
                if self.Settings.AimPointOutline then
                    playerData.Drawings.AimPointOutline.Position = aimPointPosition
                    playerData.Drawings.AimPointOutline.Transparency = transparency * self.Settings.AimPointOutlineTransparency
                    playerData.Drawings.AimPointOutline.Radius = radius
                    playerData.Drawings.AimPointOutline.Visible = true
                else
                    playerData.Drawings.AimPointOutline.Visible = false
                end
            else
                playerData.Drawings.AimPoint.Visible = false
                playerData.Drawings.AimPointOutline.Visible = false
            end
        else
            playerData.Drawings.AimPoint.Visible = false
            playerData.Drawings.AimPointOutline.Visible = false
        end
    else
        playerData.Drawings.AimPoint.Visible = false
        playerData.Drawings.AimPointOutline.Visible = false
    end
    
 
    if self.Settings.SkeletonEnabled then
        local skeletonPoints = self:GetSkeletonPoints(character)
        
        
        for _, line in pairs(playerData.Drawings.SkeletonDashed) do
            self:RemoveDrawing(line)
        end
        playerData.Drawings.SkeletonDashed = {}
        
        if skeletonPoints then
            if self.Settings.SkeletonStyle == "Line" then
                for i, points in ipairs(skeletonPoints) do
                    if i <= #playerData.Drawings.Skeleton then
                        playerData.Drawings.Skeleton[i].Line.From = points[1]
                        playerData.Drawings.Skeleton[i].Line.To = points[2]
                        playerData.Drawings.Skeleton[i].Line.Color = color
                        playerData.Drawings.Skeleton[i].Line.Transparency = transparency * self.Settings.SkeletonTransparency
                        playerData.Drawings.Skeleton[i].Line.Visible = true
                        
                        if self.Settings.SkeletonOutline then
                            playerData.Drawings.Skeleton[i].Outline.From = points[1]
                            playerData.Drawings.Skeleton[i].Outline.To = points[2]
                            playerData.Drawings.Skeleton[i].Outline.Transparency = transparency * self.Settings.SkeletonOutlineTransparency
                            playerData.Drawings.Skeleton[i].Outline.Visible = true
                        else
                            playerData.Drawings.Skeleton[i].Outline.Visible = false
                        end
                    end
                end
                
           
                for i = #skeletonPoints + 1, #playerData.Drawings.Skeleton do
                    playerData.Drawings.Skeleton[i].Line.Visible = false
                    playerData.Drawings.Skeleton[i].Outline.Visible = false
                end
            elseif self.Settings.SkeletonStyle == "Dashed" or self.Settings.SkeletonStyle == "Dotted" then
            
                for i = 1, #playerData.Drawings.Skeleton do
                    playerData.Drawings.Skeleton[i].Line.Visible = false
                    playerData.Drawings.Skeleton[i].Outline.Visible = false
                end
                
                local dashSize = self.Settings.SkeletonStyle == "Dotted" and 1 or self.Settings.SkeletonDashSize
                local gapSize = self.Settings.SkeletonDashGap
                
                for _, points in ipairs(skeletonPoints) do
                    local dashedLines = self:DrawDashedLine(
                        points[1], 
                        points[2], 
                        dashSize, 
                        gapSize, 
                        color, 
                        self.Settings.SkeletonThickness, 
                        transparency * self.Settings.SkeletonTransparency, 
                        self.Settings.ZIndex
                    )
                    
                    for _, line in ipairs(dashedLines) do
                        tableinsert(playerData.Drawings.SkeletonDashed, line)
                    end
                end
            end
        else
            for i = 1, #playerData.Drawings.Skeleton do
                playerData.Drawings.Skeleton[i].Line.Visible = false
                playerData.Drawings.Skeleton[i].Outline.Visible = false
            end
        end
    else
        for i = 1, #playerData.Drawings.Skeleton do
            playerData.Drawings.Skeleton[i].Line.Visible = false
            playerData.Drawings.Skeleton[i].Outline.Visible = false
        end
        
        for _, line in pairs(playerData.Drawings.SkeletonDashed) do
            line.Visible = false
        end
    end
    
 
    if self.Settings.HitboxEnabled then
        local hitboxPoints = self:GetHitboxPoints(character)
        
        if hitboxPoints then
            for i, point in ipairs(hitboxPoints) do
                if i <= #playerData.Drawings.Hitbox then
                    playerData.Drawings.Hitbox[i].Position = point
                    playerData.Drawings.Hitbox[i].Color = color
                    playerData.Drawings.Hitbox[i].Transparency = transparency * self.Settings.HitboxTransparency
                    playerData.Drawings.Hitbox[i].Visible = true
                end
            end
            
          
            for i = #hitboxPoints + 1, #playerData.Drawings.Hitbox do
                playerData.Drawings.Hitbox[i].Visible = false
            end
        else
            for i = 1, #playerData.Drawings.Hitbox do
                playerData.Drawings.Hitbox[i].Visible = false
            end
        end
    else
        for i = 1, #playerData.Drawings.Hitbox do
            playerData.Drawings.Hitbox[i].Visible = false
        end
    end
end


function ESP:CreateObjectESP(object, customSettings)
    if not object then return end
    
    local objectId = tostring(object:GetFullName())
    
 
    local settings = {}
    for key, value in pairs(self.Settings) do
        settings[key] = value
    end
    

    if customSettings then
        for key, value in pairs(customSettings) do
            settings[key] = value
        end
    end
    
    local objectData = {
        Object = object,
        Settings = settings,
        Drawings = {
            Box = self:CreateDrawing("Square", {
                Visible = false,
                Color = settings.BoxColor,
                Thickness = settings.BoxThickness,
                Transparency = settings.BoxTransparency,
                Filled = settings.BoxFilled,
                ZIndex = settings.ZIndex
            }),
            BoxOutline = self:CreateDrawing("Square", {
                Visible = false,
                Color = settings.BoxOutlineColor,
                Thickness = settings.BoxThickness + 2,
                Transparency = settings.BoxOutlineTransparency,
                Filled = false,
                ZIndex = settings.ZIndex - 1
            }),
            BoxFill = self:CreateDrawing("Square", {
                Visible = false,
                Color = settings.BoxColor,
                Transparency = settings.BoxFilledTransparency,
                Filled = true,
                ZIndex = settings.ZIndex - 2
            }),
            BoxCorners = {},
            Box3D = {},
            Name = self:CreateDrawing("Text", {
                Visible = false,
                Color = settings.NameColor,
                Transparency = settings.NameTransparency,
                Size = settings.NameSize,
                Center = true,
                Outline = settings.NameOutline,
                OutlineColor = settings.NameOutlineColor,
                Font = settings.NameFont,
                ZIndex = settings.ZIndex
            }),
            NameBackground = self:CreateDrawing("Square", {
                Visible = false,
                Color = settings.NameBackgroundColor,
                Transparency = settings.NameBackgroundTransparency,
                Filled = true,
                ZIndex = settings.ZIndex - 1
            }),
            Distance = self:CreateDrawing("Text", {
                Visible = false,
                Color = settings.DistanceColor,
                Transparency = settings.DistanceTransparency,
                Size = settings.DistanceSize,
                Center = true,
                Outline = settings.DistanceOutline,
                OutlineColor = settings.DistanceOutlineColor,
                Font = settings.DistanceFont,
                ZIndex = settings.ZIndex
            }),
            DistanceBackground = self:CreateDrawing("Square", {
                Visible = false,
                Color = settings.DistanceBackgroundColor,
                Transparency = settings.DistanceBackgroundTransparency,
                Filled = true,
                ZIndex = settings.ZIndex - 1
            }),
            Tracer = self:CreateDrawing("Line", {
                Visible = false,
                Color = settings.TracerColor,
                Thickness = settings.TracerThickness,
                Transparency = settings.TracerTransparency,
                ZIndex = settings.ZIndex
            }),
            TracerOutline = self:CreateDrawing("Line", {
                Visible = false,
                Color = settings.TracerOutlineColor,
                Thickness = settings.TracerThickness + 2,
                Transparency = settings.TracerOutlineTransparency,
                ZIndex = settings.ZIndex - 1
            }),
            TracerDashed = {}
        }
    }
    
  
    for i = 1, 8 do
        objectData.Drawings.BoxCorners[i] = {
            Line = self:CreateDrawing("Line", {
                Visible = false,
                Color = settings.BoxColor,
                Thickness = settings.BoxThickness,
                Transparency = settings.BoxTransparency,
                ZIndex = settings.ZIndex
            }),
            Outline = self:CreateDrawing("Line", {
                Visible = false,
                Color = settings.BoxOutlineColor,
                Thickness = settings.BoxThickness + 2,
                Transparency = settings.BoxOutlineTransparency,
                ZIndex = settings.ZIndex - 1
            })
        }
    end
    
 
    for i = 1, 12 do
        objectData.Drawings.Box3D[i] = {
            Line = self:CreateDrawing("Line", {
                Visible = false,
                Color = settings.BoxColor,
                Thickness = settings.BoxThickness,
                Transparency = settings.BoxTransparency,
                ZIndex = settings.ZIndex
            }),
            Outline = self:CreateDrawing("Line", {
                Visible = false,
                Color = settings.BoxOutlineColor,
                Thickness = settings.BoxThickness + 2,
                Transparency = settings.BoxOutlineTransparency,
                ZIndex = settings.ZIndex - 1
            })
        }
    end
    
    self.Objects[objectId] = objectData
    return objectData
end

function ESP:RemoveObjectESP(object)
    local objectId = tostring(object:GetFullName())
    local objectData = self.Objects[objectId]
    
    if objectData then
        for _, drawing in pairs(objectData.Drawings) do
            if type(drawing) == "table" then
                if drawing.Line then
                    self:RemoveDrawing(drawing.Line)
                    self:RemoveDrawing(drawing.Outline)
                else
                    for _, subDrawing in pairs(drawing) do
                        if type(subDrawing) == "table" then
                            self:RemoveDrawing(subDrawing.Line)
                            self:RemoveDrawing(subDrawing.Outline)
                        else
                            self:RemoveDrawing(subDrawing)
                        end
                    end
                end
            else
                self:RemoveDrawing(drawing)
            end
        end
        
        self.Objects[objectId] = nil
    end
end

function ESP:UpdateObjectESP(object)
    local objectId = tostring(object:GetFullName())
    local objectData = self.Objects[objectId]
    
    if not objectData then return end
    
  
    local position
    if object:IsA("Model") then
        local primaryPart = object.PrimaryPart or object:FindFirstChildWhichIsA("BasePart")
        if not primaryPart then return end
        position = primaryPart.Position
    elseif object:IsA("BasePart") then
        position = object.Position
    else
        return
    end
    
 
    local distance = self:GetDistance(position)
    if distance > objectData.Settings.MaxDistance then
        for _, drawing in pairs(objectData.Drawings) do
            if type(drawing) == "table" then
                if drawing.Line then
                    drawing.Line.Visible = false
                    drawing.Outline.Visible = false
                else
                    for _, subDrawing in pairs(drawing) do
                        if type(subDrawing) == "table" then
                            subDrawing.Line.Visible = false
                            subDrawing.Outline.Visible = false
                        else
                            subDrawing.Visible = false
                        end
                    end
                end
            else
                drawing.Visible = false
            end
        end
        return
    end
    
   
    local transparency = self:CalculateTransparency(distance)
    
  
    if objectData.Settings.BoxEnabled then
        local boxCorners = self:GetBoxCorners(object)
        
     
        objectData.Drawings.Box.Visible = false
        objectData.Drawings.BoxOutline.Visible = false
        objectData.Drawings.BoxFill.Visible = false
        
        for _, corner in pairs(objectData.Drawings.BoxCorners) do
            corner.Line.Visible = false
            corner.Outline.Visible = false
        end
        
        for _, line in pairs(objectData.Drawings.Box3D) do
            line.Line.Visible = false
            line.Outline.Visible = false
        end
        
        if boxCorners then
            local topLeft = boxCorners.TopLeft
            local bottomRight = boxCorners.BottomRight
            local boxSize = bottomRight - topLeft
            
            if objectData.Settings.BoxType == "2D" then
                objectData.Drawings.Box.Position = topLeft
                objectData.Drawings.Box.Size = boxSize
                objectData.Drawings.Box.Color = objectData.Settings.BoxColor
                objectData.Drawings.Box.Transparency = transparency * objectData.Settings.BoxTransparency
                objectData.Drawings.Box.Visible = true
                
                if objectData.Settings.BoxOutline then
                    objectData.Drawings.BoxOutline.Position = topLeft
                    objectData.Drawings.BoxOutline.Size = boxSize
                    objectData.Drawings.BoxOutline.Transparency = transparency * objectData.Settings.BoxOutlineTransparency
                    objectData.Drawings.BoxOutline.Visible = true
                end
                
                if objectData.Settings.BoxFilled then
                    objectData.Drawings.BoxFill.Position = topLeft
                    objectData.Drawings.BoxFill.Size = boxSize
                    objectData.Drawings.BoxFill.Color = objectData.Settings.BoxColor
                    objectData.Drawings.BoxFill.Transparency = transparency * objectData.Settings.BoxFilledTransparency
                    objectData.Drawings.BoxFill.Visible = true
                end
            elseif objectData.Settings.BoxType == "Corner" then
                local cornerPoints = self:GetCornerBoxPoints(boxCorners)
                
                if cornerPoints then
                    for i, points in ipairs(cornerPoints) do
                        if i <= #objectData.Drawings.BoxCorners then
                            objectData.Drawings.BoxCorners[i].Line.From = points[1]
                            objectData.Drawings.BoxCorners[i].Line.To = points[2]
                            objectData.Drawings.BoxCorners[i].Line.Color = objectData.Settings.BoxColor
                            objectData.Drawings.BoxCorners[i].Line.Transparency = transparency * objectData.Settings.BoxTransparency
                            objectData.Drawings.BoxCorners[i].Line.Visible = true
                            
                            if objectData.Settings.BoxOutline then
                                objectData.Drawings.BoxCorners[i].Outline.From = points[1]
                                objectData.Drawings.BoxCorners[i].Outline.To = points[2]
                                objectData.Drawings.BoxCorners[i].Outline.Transparency = transparency * objectData.Settings.BoxOutlineTransparency
                                objectData.Drawings.BoxCorners[i].Outline.Visible = true
                            end
                        end
                    end
                end
            elseif objectData.Settings.BoxType == "3D" then
                local corners3D = self:Get3DBoxCorners(object)
                
                if corners3D then
                 
                    local edges = {
                      
                        {1, 2}, {2, 4}, {4, 3}, {3, 1},
                       
                        {5, 6}, {6, 8}, {8, 7}, {7, 5},
                        
                        {1, 5}, {2, 6}, {3, 7}, {4, 8}
                    }
                    
                    for i, edge in ipairs(edges) do
                        if i <= #objectData.Drawings.Box3D then
                            objectData.Drawings.Box3D[i].Line.From = corners3D[edge[1]]
                            objectData.Drawings.Box3D[i].Line.To = corners3D[edge[2]]
                            objectData.Drawings.Box3D[i].Line.Color = objectData.Settings.BoxColor
                            objectData.Drawings.Box3D[i].Line.Transparency = transparency * objectData.Settings.BoxTransparency
                            objectData.Drawings.Box3D[i].Line.Visible = true
                            
                            if objectData.Settings.BoxOutline then
                                objectData.Drawings.Box3D[i].Outline.From = corners3D[edge[1]]
                                objectData.Drawings.Box3D[i].Outline.To = corners3D[edge[2]]
                                objectData.Drawings.Box3D[i].Outline.Transparency = transparency * objectData.Settings.BoxOutlineTransparency
                                objectData.Drawings.Box3D[i].Outline.Visible = true
                            end
                        end
                    end
                end
            end
        end
    else
        objectData.Drawings.Box.Visible = false
        objectData.Drawings.BoxOutline.Visible = false
        objectData.Drawings.BoxFill.Visible = false
        
        for _, corner in pairs(objectData.Drawings.BoxCorners) do
            corner.Line.Visible = false
            corner.Outline.Visible = false
        end
        
        for _, line in pairs(objectData.Drawings.Box3D) do
            line.Line.Visible = false
            line.Outline.Visible = false
        end
    end
    

    if objectData.Settings.NameEnabled then
        local screenPos, onScreen, depth = self:WorldToScreen(position)
        local boxCorners = self:GetBoxCorners(object)
        
        if onScreen then
            local displayName = object.Name
            local textSize = self:CalculateTextSize(distance)
            local namePosition = self:CalculatePosition(
                objectData.Settings.NamePosition, 
                boxCorners, 
                screenPos, 
                objectData.Settings.NameXOffset, 
                objectData.Settings.NameYOffset
            )
            
            objectData.Drawings.Name.Position = namePosition
            objectData.Drawings.Name.Text = displayName
            objectData.Drawings.Name.Transparency = transparency * objectData.Settings.NameTransparency
            objectData.Drawings.Name.Size = textSize
            objectData.Drawings.Name.Visible = true
            
            if objectData.Settings.NameBackground then
                local textBounds = objectData.Drawings.Name.TextBounds
                objectData.Drawings.NameBackground.Position = Vector2new(
                    namePosition.X - textBounds.X/2 - objectData.Settings.NameBackgroundPadding,
                    namePosition.Y - textBounds.Y/2 - objectData.Settings.NameBackgroundPadding
                )
                objectData.Drawings.NameBackground.Size = Vector2new(
                    textBounds.X + objectData.Settings.NameBackgroundPadding * 2,
                    textBounds.Y + objectData.Settings.NameBackgroundPadding * 2
                )
                objectData.Drawings.NameBackground.Transparency = transparency * objectData.Settings.NameBackgroundTransparency
                objectData.Drawings.NameBackground.Visible = true
            else
                objectData.Drawings.NameBackground.Visible = false
            end
        else
            objectData.Drawings.Name.Visible = false
            objectData.Drawings.NameBackground.Visible = false
        end
    else
        objectData.Drawings.Name.Visible = false
        objectData.Drawings.NameBackground.Visible = false
    end
    

    if objectData.Settings.DistanceEnabled then
        local screenPos, onScreen, depth = self:WorldToScreen(position)
        local boxCorners = self:GetBoxCorners(object)
        
        if onScreen then
            local distanceText = self:GetDistanceText(distance)
            local textSize = self:CalculateTextSize(distance)
            local distancePosition = self:CalculatePosition(
                objectData.Settings.DistancePosition, 
                boxCorners, 
                screenPos, 
                objectData.Settings.DistanceXOffset, 
                objectData.Settings.DistanceYOffset
            )
            
            objectData.Drawings.Distance.Position = distancePosition
            objectData.Drawings.Distance.Text = distanceText
            objectData.Drawings.Distance.Transparency = transparency * objectData.Settings.DistanceTransparency
            objectData.Drawings.Distance.Size = textSize
            objectData.Drawings.Distance.Visible = true
            
            if objectData.Settings.DistanceBackground then
                local textBounds = objectData.Drawings.Distance.TextBounds
                objectData.Drawings.DistanceBackground.Position = Vector2new(
                    distancePosition.X - textBounds.X/2 - objectData.Settings.DistanceBackgroundPadding,
                    distancePosition.Y - textBounds.Y/2 - objectData.Settings.DistanceBackgroundPadding
                )
                objectData.Drawings.DistanceBackground.Size = Vector2new(
                    textBounds.X + objectData.Settings.DistanceBackgroundPadding * 2,
                    textBounds.Y + objectData.Settings.DistanceBackgroundPadding * 2
                )
                objectData.Drawings.DistanceBackground.Transparency = transparency * objectData.Settings.DistanceBackgroundTransparency
                objectData.Drawings.DistanceBackground.Visible = true
            else
                objectData.Drawings.DistanceBackground.Visible = false
            end
        else
            objectData.Drawings.Distance.Visible = false
            objectData.Drawings.DistanceBackground.Visible = false
        end
    else
        objectData.Drawings.Distance.Visible = false
        objectData.Drawings.DistanceBackground.Visible = false
    end
    

    if objectData.Settings.TracerEnabled then
        local screenPos, onScreen, depth = self:WorldToScreen(position)
        
        if onScreen then
            local from
            
            if objectData.Settings.TracerOrigin == "Bottom" then
                from = Vector2new(Camera.ViewportSize.X / 2 + objectData.Settings.TracerXOffset, Camera.ViewportSize.Y + objectData.Settings.TracerYOffset)
            elseif objectData.Settings.TracerOrigin == "Center" then
                from = Vector2new(Camera.ViewportSize.X / 2 + objectData.Settings.TracerXOffset, Camera.ViewportSize.Y / 2 + objectData.Settings.TracerYOffset)
            elseif objectData.Settings.TracerOrigin == "Mouse" then
                from = UserInputService:GetMouseLocation() + Vector2new(objectData.Settings.TracerXOffset, objectData.Settings.TracerYOffset)
            end
            
          
            for _, line in pairs(objectData.Drawings.TracerDashed) do
                self:RemoveDrawing(line)
            end
            objectData.Drawings.TracerDashed = {}
            
            if objectData.Settings.TracerStyle == "Line" then
                objectData.Drawings.Tracer.From = from
                objectData.Drawings.Tracer.To = screenPos
                objectData.Drawings.Tracer.Color = objectData.Settings.TracerColor
                objectData.Drawings.Tracer.Transparency = transparency * objectData.Settings.TracerTransparency
                objectData.Drawings.Tracer.Visible = true
                
                if objectData.Settings.TracerOutline then
                    objectData.Drawings.TracerOutline.From = from
                    objectData.Drawings.TracerOutline.To = screenPos
                    objectData.Drawings.TracerOutline.Transparency = transparency * objectData.Settings.TracerOutlineTransparency
                    objectData.Drawings.TracerOutline.Visible = true
                else
                    objectData.Drawings.TracerOutline.Visible = false
                end
            elseif objectData.Settings.TracerStyle == "Dashed" or objectData.Settings.TracerStyle == "Dotted" then
                objectData.Drawings.Tracer.Visible = false
                objectData.Drawings.TracerOutline.Visible = false
                
                local dashSize = objectData.Settings.TracerStyle == "Dotted" and 1 or objectData.Settings.TracerDashSize
                local gapSize = objectData.Settings.TracerDashGap
                
                objectData.Drawings.TracerDashed = self:DrawDashedLine(
                    from, 
                    screenPos, 
                    dashSize, 
                    gapSize, 
                    objectData.Settings.TracerColor, 
                    objectData.Settings.TracerThickness, 
                    transparency * objectData.Settings.TracerTransparency, 
                    objectData.Settings.ZIndex
                )
            end
        else
            objectData.Drawings.Tracer.Visible = false
            objectData.Drawings.TracerOutline.Visible = false
            
            for _, line in pairs(objectData.Drawings.TracerDashed) do
                line.Visible = false
            end
        end
    else
        objectData.Drawings.Tracer.Visible = false
        objectData.Drawings.TracerOutline.Visible = false
        
        for _, line in pairs(objectData.Drawings.TracerDashed) do
            line.Visible = false
        end
    end
end


function ESP:Init()
 
    self.Connections.PlayerAdded = Players.PlayerAdded:Connect(function(player)
        self:CreatePlayerESP(player)
    end)
    
    self.Connections.PlayerRemoving = Players.PlayerRemoving:Connect(function(player)
        self:RemovePlayerESP(player)
    end)
    
    self.Connections.RenderStepped = RunService.RenderStepped:Connect(function()
        if not self.Enabled then return end
        
       
        if self.Settings.RainbowMode then
            self._rainbow = (self._rainbow + self.Settings.RainbowSpeed * 0.01) % 1
        end
        
        self._pulse = (self._pulse + 0.05) % (mathpi * 2)
        
     
        for player, playerData in pairs(self.Players) do
            self:UpdatePlayerESP(player)
        end
        
      
        for objectId, objectData in pairs(self.Objects) do
            if objectData.Object and objectData.Object.Parent then
                self:UpdateObjectESP(objectData.Object)
            else
                self:RemoveObjectESP(objectData.Object)
            end
        end
    end)
    
    self.Connections.InputBegan = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == self.Settings.ToggleKey then
            self.Enabled = not self.Enabled
            
            if not self.Enabled then
                for _, playerData in pairs(self.Players) do
                    for _, drawing in pairs(playerData.Drawings) do
                        if type(drawing) == "table" then
                            if drawing.Line then
                                drawing.Line.Visible = false
                                drawing.Outline.Visible = false
                            else
                                for _, subDrawing in pairs(drawing) do
                                    if type(subDrawing) == "table" then
                                        subDrawing.Line.Visible = false
                                        subDrawing.Outline.Visible = false
                                    else
                                        subDrawing.Visible = false
                                    end
                                end
                            end
                        else
                            drawing.Visible = false
                        end
                    end
                end
                
                for _, objectData in pairs(self.Objects) do
                    for _, drawing in pairs(objectData.Drawings) do
                        if type(drawing) == "table" then
                            if drawing.Line then
                                drawing.Line.Visible = false
                                drawing.Outline.Visible = false
                            else
                                for _, subDrawing in pairs(drawing) do
                                    if type(subDrawing) == "table" then
                                        subDrawing.Line.Visible = false
                                        subDrawing.Outline.Visible = false
                                    else
                                        subDrawing.Visible = false
                                    end
                                end
                            end
                        else
                            drawing.Visible = false
                        end
                    end
                end
            end
        elseif input.KeyCode == self.Settings.BoxToggleKey then
            self.Settings.BoxEnabled = not self.Settings.BoxEnabled
        elseif input.KeyCode == self.Settings.NameToggleKey then
            self.Settings.NameEnabled = not self.Settings.NameEnabled
        elseif input.KeyCode == self.Settings.DistanceToggleKey then
            self.Settings.DistanceEnabled = not self.Settings.DistanceEnabled
        elseif input.KeyCode == self.Settings.HealthToggleKey then
            self.Settings.HealthEnabled = not self.Settings.HealthEnabled
        elseif input.KeyCode == self.Settings.TracerToggleKey then
            self.Settings.TracerEnabled = not self.Settings.TracerEnabled
        elseif input.KeyCode == self.Settings.ChamsToggleKey then
            self.Settings.ChamsEnabled = not self.Settings.ChamsEnabled
        elseif input.KeyCode == self.Settings.SkeletonToggleKey then
            self.Settings.SkeletonEnabled = not self.Settings.SkeletonEnabled
        elseif input.KeyCode == self.Settings.HeadDotToggleKey then
            self.Settings.HeadDotEnabled = not self.Settings.HeadDotEnabled
        end
    end)
    

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            self:CreatePlayerESP(player)
        end
    end
    
    return self
end
-- Removing the esp and everything with it
function ESP:Destroy()
    -- Disconnect all connections
    for _, connection in pairs(self.Connections) do
        connection:Disconnect()
    end
    
    -- Clear all drawings
    self:ClearDrawings()
    
    -- Clear tables
    self.Connections = {}
    self.Players = {}
    self.Objects = {}
    self._transitions = {}
end


function ESP:Toggle(enabled)
    if enabled ~= nil then
        self.Enabled = enabled
    else
        self.Enabled = not self.Enabled
    end
    
    return self.Enabled
end

function ESP:ToggleBox(enabled)
    if enabled ~= nil then
        self.Settings.BoxEnabled = enabled
    else
        self.Settings.BoxEnabled = not self.Settings.BoxEnabled
    end
    
    return self.Settings.BoxEnabled
end

function ESP:SetBoxType(boxType)
    self.Settings.BoxType = boxType
    return boxType
end

function ESP:ToggleName(enabled)
    if enabled ~= nil then
        self.Settings.NameEnabled = enabled
    else
        self.Settings.NameEnabled = not self.Settings.NameEnabled
    end
    
    return self.Settings.NameEnabled
end

function ESP:ToggleDistance(enabled)
    if enabled ~= nil then
        self.Settings.DistanceEnabled = enabled
    else
        self.Settings.DistanceEnabled = not self.Settings.DistanceEnabled
    end
    
    return self.Settings.DistanceEnabled
end

function ESP:ToggleHealth(enabled)
    if enabled ~= nil then
        self.Settings.HealthEnabled = enabled
    else
        self.Settings.HealthEnabled = not self.Settings.HealthEnabled
    end
    
    return self.Settings.HealthEnabled
end

function ESP:ToggleTracer(enabled)
    if enabled ~= nil then
        self.Settings.TracerEnabled = enabled
    else
        self.Settings.TracerEnabled = not self.Settings.TracerEnabled
    end
    
    return self.Settings.TracerEnabled
end

function ESP:ToggleChams(enabled)
    if enabled ~= nil then
        self.Settings.ChamsEnabled = enabled
    else
        self.Settings.ChamsEnabled = not self.Settings.ChamsEnabled
    end
    
    return self.Settings.ChamsEnabled
end

function ESP:ToggleSkeleton(enabled)
    if enabled ~= nil then
        self.Settings.SkeletonEnabled = enabled
    else
        self.Settings.SkeletonEnabled = not self.Settings.SkeletonEnabled
    end
    
    return self.Settings.SkeletonEnabled
end

function ESP:ToggleHeadDot(enabled)
    if enabled ~= nil then
        self.Settings.HeadDotEnabled = enabled
    else
        self.Settings.HeadDotEnabled = not self.Settings.HeadDotEnabled
    end
    
    return self.Settings.HeadDotEnabled
end

function ESP:ToggleTeamCheck(enabled)
    if enabled ~= nil then
        self.Settings.TeamCheck = enabled
    else
        self.Settings.TeamCheck = not self.Settings.TeamCheck
    end
    
    return self.Settings.TeamCheck
end

function ESP:ToggleVisibilityCheck(enabled)
    if enabled ~= nil then
        self.Settings.VisibilityCheck = enabled
    else
        self.Settings.VisibilityCheck = not self.Settings.VisibilityCheck
    end
    
    return self.Settings.VisibilityCheck
end

function ESP:SetColor(color)
    self.Settings.BoxColor = color
    self.Settings.NameColor = color
    self.Settings.DistanceColor = color
    self.Settings.TracerColor = color
    self.Settings.SkeletonColor = color
    
    return color
end

function ESP:SetTeamColor(color)
    self.Settings.TeamColor = color
    
    return color
end

function ESP:SetEnemyColor(color)
    self.Settings.EnemyColor = color
    
    return color
end

function ESP:SetMaxDistance(distance)
    self.Settings.MaxDistance = distance
    
    return distance
end

function ESP:AddToWhitelist(player)
    if type(player) == "string" then
        tableinsert(self.Settings.Whitelist, player)
    elseif type(player) == "number" then
        tableinsert(self.Settings.Whitelist, player)
    elseif player:IsA("Player") then
        tableinsert(self.Settings.Whitelist, player.Name)
    end
    
    return self.Settings.Whitelist
end

function ESP:RemoveFromWhitelist(player)
    if type(player) == "string" then
        for i, name in ipairs(self.Settings.Whitelist) do
            if name == player then
                tableremove(self.Settings.Whitelist, i)
                break
            end
        end
    elseif type(player) == "number" then
        for i, id in ipairs(self.Settings.Whitelist) do
            if id == player then
                tableremove(self.Settings.Whitelist, i)
                break
            end
        end
    elseif player:IsA("Player") then
        for i, name in ipairs(self.Settings.Whitelist) do
            if name == player.Name then
                tableremove(self.Settings.Whitelist, i)
                break
            end
        end
    end
    
    return self.Settings.Whitelist
end

function ESP:AddToBlacklist(player)
    if type(player) == "string" then
        tableinsert(self.Settings.Blacklist, player)
    elseif type(player) == "number" then
        tableinsert(self.Settings.Blacklist, player)
    elseif player:IsA("Player") then
        tableinsert(self.Settings.Blacklist, player.Name)
    end
    
    return self.Settings.Blacklist
end

function ESP:RemoveFromBlacklist(player)
    if type(player) == "string" then
        for i, name in ipairs(self.Settings.Blacklist) do
            if name == player then
                tableremove(self.Settings.Blacklist, i)
                break
            end
        end
    elseif type(player) == "number" then
        for i, id in ipairs(self.Settings.Blacklist) do
            if id == player then
                tableremove(self.Settings.Blacklist, i)
                break
            end
        end
    elseif player:IsA("Player") then
        for i, name in ipairs(self.Settings.Blacklist) do
            if name == player.Name then
                tableremove(self.Settings.Blacklist, i)
                break
            end
        end
    end
    
    return self.Settings.Blacklist
end

function ESP:ClearWhitelist()
    self.Settings.Whitelist = {}
    return self.Settings.Whitelist
end

function ESP:ClearBlacklist()
    self.Settings.Blacklist = {}
    return self.Settings.Blacklist
end

function ESP:SetRefreshRate(rate)
    self.Settings.RefreshRate = rate
    return rate
end

function ESP:SetTracerOrigin(origin)
    self.Settings.TracerOrigin = origin
    return origin
end

function ESP:SetTracerStyle(style)
    self.Settings.TracerStyle = style
    return style
end

function ESP:SetSkeletonStyle(style)
    self.Settings.SkeletonStyle = style
    return style
end

function ESP:SetHealthBarType(healthType)
    self.Settings.HealthType = healthType
    return healthType
end

function ESP:ToggleRainbowMode(enabled)
    if enabled ~= nil then
        self.Settings.RainbowMode = enabled
    else
        self.Settings.RainbowMode = not self.Settings.RainbowMode
    end
    
    return self.Settings.RainbowMode
end

function ESP:SetRainbowSpeed(speed)
    self.Settings.RainbowSpeed = speed
    return speed
end

function ESP:SetTransparency(transparency)
    self.Settings.BoxTransparency = transparency
    self.Settings.NameTransparency = transparency
    self.Settings.DistanceTransparency = transparency
    self.Settings.HealthTransparency = transparency
    self.Settings.TracerTransparency = transparency
    self.Settings.SkeletonTransparency = transparency
    self.Settings.HeadDotTransparency = transparency
    
    return transparency
end

function ESP:SetThickness(thickness)
    self.Settings.BoxThickness = thickness
    self.Settings.TracerThickness = thickness
    self.Settings.SkeletonThickness = thickness
    self.Settings.HeadDotThickness = thickness
    
    return thickness
end


function ESP:SetBoxPadding(padding)
    if type(padding) == "number" then
        self.Settings.BoxPadding = Vector3new(padding, padding, padding)
    else
        self.Settings.BoxPadding = padding
    end
    return self.Settings.BoxPadding
end


function ESP:SetNamePosition(position, xOffset, yOffset)
    self.Settings.NamePosition = position
    if xOffset then self.Settings.NameXOffset = xOffset end
    if yOffset then self.Settings.NameYOffset = yOffset end
    return position
end

function ESP:SetDistancePosition(position, xOffset, yOffset)
    self.Settings.DistancePosition = position
    if xOffset then self.Settings.DistanceXOffset = xOffset end
    if yOffset then self.Settings.DistanceYOffset = yOffset end
    return position
end

function ESP:SetHealthPosition(position, xOffset, yOffset)
    self.Settings.HealthPosition = position
    if xOffset then self.Settings.HealthXOffset = xOffset end
    if yOffset then self.Settings.HealthYOffset = yOffset end
    return position
end

function ESP:SetToolPosition(position, xOffset, yOffset)
    self.Settings.ToolPosition = position
    if xOffset then self.Settings.ToolXOffset = xOffset end
    if yOffset then self.Settings.ToolYOffset = yOffset end
    return position
end

function ESP:SetStatePosition(position, xOffset, yOffset)
    self.Settings.StatePosition = position
    if xOffset then self.Settings.StateXOffset = xOffset end
    if yOffset then self.Settings.StateYOffset = yOffset end
    return position
end

function ESP:SetTracerOffset(xOffset, yOffset)
    if xOffset then self.Settings.TracerXOffset = xOffset end
    if yOffset then self.Settings.TracerYOffset = yOffset end
    return Vector2new(self.Settings.TracerXOffset, self.Settings.TracerYOffset)
end

function ESP:SetHeadDotOffset(xOffset, yOffset)
    if xOffset then self.Settings.HeadDotXOffset = xOffset end
    if yOffset then self.Settings.HeadDotYOffset = yOffset end
    return Vector2new(self.Settings.HeadDotXOffset, self.Settings.HeadDotYOffset)
end

function ESP:SetAimPointOffset(xOffset, yOffset)
    if xOffset then self.Settings.AimPointXOffset = xOffset end
    if yOffset then self.Settings.AimPointYOffset = yOffset end
    return Vector2new(self.Settings.AimPointXOffset, self.Settings.AimPointYOffset)
end


function ESP:Add(object, options)
    if not object then return end
    
    if object:IsA("Player") then
        local playerData = self:CreatePlayerESP(object)
        return playerData
    else
        local objectData = self:CreateObjectESP(object, options)
        return objectData
    end
end

function ESP:Remove(object)
    if not object then return end
    
    if object:IsA("Player") then
        self:RemovePlayerESP(object)
    else
        self:RemoveObjectESP(object)
    end
end

function ESP:AddBox(object, options)
    local customSettings = options or {}
    customSettings.BoxEnabled = true
    customSettings.NameEnabled = false
    customSettings.DistanceEnabled = false
    customSettings.TracerEnabled = false
    
    return self:Add(object, customSettings)
end

function ESP:AddName(object, options)
    local customSettings = options or {}
    customSettings.BoxEnabled = false
    customSettings.NameEnabled = true
    customSettings.DistanceEnabled = false
    customSettings.TracerEnabled = false
    
    return self:Add(object, customSettings)
end

function ESP:AddDistance(object, options)
    local customSettings = options or {}
    customSettings.BoxEnabled = false
    customSettings.NameEnabled = false
    customSettings.DistanceEnabled = true
    customSettings.TracerEnabled = false
    
    return self:Add(object, customSettings)
end

function ESP:AddTracer(object, options)
    local customSettings = options or {}
    customSettings.BoxEnabled = false
    customSettings.NameEnabled = false
    customSettings.DistanceEnabled = false
    customSettings.TracerEnabled = true
    
    return self:Add(object, customSettings)
end

function ESP:AddFull(object, options)
    local customSettings = options or {}
    customSettings.BoxEnabled = true
    customSettings.NameEnabled = true
    customSettings.DistanceEnabled = true
    customSettings.TracerEnabled = true
    
    return self:Add(object, customSettings)
end


local espLib = ESP:Init()


return espLib
