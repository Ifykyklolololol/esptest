--[[
Enhanced Roblox ESP Library
Features:
- Multiple Box Types: 2D, 3D, Corner, Filled, Rounded, Gradient
- Improved visuals with smoother outlines and better colors
- Name Tags, Distance, Health Bar, Tracers, Chams, Skeleton ESP, Head Dot
- Team Check, Visibility Check, Toggle for each element
- Max Distance Setting, Whitelist/Blacklist Players
- Custom Colors, Rainbow Mode, Transparency/Thickness Control
- Tool ESP, State Display, AimPoint, Hitbox Markers
- Simple positioning system (top, bottom, left, right)
- Adaptive scaling based on distance
- Smooth animations and transitions
- And many more customization options
]]

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Constants
local Vector2new = Vector2.new
local Vector3new = Vector3.new
local CFramenew = CFrame.new
local Color3new = Color3.new
local Color3fromRGB = Color3.fromRGB
local Color3fromHSV = Color3.fromHSV
local Drawingnew = Drawing.new
local WorldToViewportPoint = Camera.WorldToViewportPoint
local WorldToScreenPoint = Camera.WorldToScreenPoint
local RaycastParamsnew = RaycastParams.new
local EnumRaycastFilterTypeBlacklist = Enum.RaycastFilterType.Blacklist
local FindFirstChild = game.FindFirstChild
local IsA = game.IsA
local taskwait = task.wait
local taskspawn = task.spawn
local mathfloor = math.floor
local mathabs = math.abs
local mathclamp = math.clamp
local mathcos = math.cos
local mathsin = math.sin
local mathrad = math.rad
local mathhuge = math.huge
local mathmin = math.min
local mathmax = math.max
local mathpi = math.pi
local tableinsert = table.insert
local tableremove = table.remove
local tablefind = table.find
local stringsub = string.sub
local stringlen = string.len
local stringformat = string.format
local stringlower = string.lower

-- ESP Library
local ESP = {
Enabled = true,
Drawings = {},
Players = {},
Objects = {},
Connections = {},

-- Settings
Settings = {
    -- General
    RefreshRate = 0.01,
    MaxDistance = 1000,
    TeamCheck = false,
    VisibilityCheck = false,
    IgnoreInvisible = true,
    IgnoreDead = true,
    IgnoreNPCs = false,
    IgnoreFriends = false,
    UseDisplayName = false,
    AlwaysOnTop = true,
    DrawOnTop = true,
    ZIndex = 1,
    RenderPriority = 1,
    FadeWithDistance = true,
    VisibilityFade = true,
    SmoothTransitions = true,
    TransitionSpeed = 0.2,
    
    -- Box ESP
    BoxEnabled = true,
    BoxType = "2D", -- "2D", "3D", "Corner", "Filled", "Rounded", "Gradient"
    BoxColor = Color3fromRGB(255, 255, 255),
    BoxTransparency = 0.7,
    BoxThickness = 1,
    BoxFilled = false,
    BoxFilledTransparency = 0.3,
    BoxOutline = true,
    BoxOutlineColor = Color3fromRGB(0, 0, 0),
    BoxOutlineTransparency = 0.5,
    BoxRoundedRadius = 5,
    BoxGradientColor = Color3fromRGB(0, 0, 255),
    UsePartBoundingBox = true,
    BoxPadding = Vector3new(0.5, 0.5, 0.5),
    CornerSize = 8, -- Size of corner segments for corner box
    
    -- Name Tags
    NameEnabled = true,
    NameColor = Color3fromRGB(255, 255, 255),
    NameTransparency = 0.7,
    NameOutline = true,
    NameOutlineColor = Color3fromRGB(0, 0, 0),
    NameOutlineTransparency = 0.5,
    NameSize = 14,
    NameFont = 2, -- Drawing.Fonts.UI
    NamePosition = "top", -- top, bottom, left, right
    NameYOffset = -15, -- Additional Y offset
    NameXOffset = 0, -- Additional X offset
    
    -- Distance
    DistanceEnabled = true,
    DistanceColor = Color3fromRGB(255, 255, 255),
    DistanceTransparency = 0.7,
    DistanceOutline = true,
    DistanceOutlineColor = Color3fromRGB(0, 0, 0),
    DistanceOutlineTransparency = 0.5,
    DistanceSize = 13,
    DistanceFont = 2, -- Drawing.Fonts.UI
    DistancePosition = "bottom", -- top, bottom, left, right
    DistanceYOffset = 15, -- Additional Y offset
    DistanceXOffset = 0, -- Additional X offset
    DistanceTextSize = true, -- Adjust text size based on distance
    
    -- Health Bar
    HealthEnabled = true,
    HealthType = "Vertical", -- "Vertical", "Horizontal"
    HealthColor = Color3fromRGB(0, 255, 0),
    HealthTransparency = 0.7,
    HealthOutline = true,
    HealthOutlineColor = Color3fromRGB(0, 0, 0),
    HealthOutlineTransparency = 0.5,
    HealthThickness = 1,
    HealthPosition = "left", -- left, right, top, bottom
    HealthYOffset = 0, -- Additional Y offset
    HealthXOffset = -5, -- Additional X offset
    HealthBarThickness = 2,
    HealthGradient = true, -- Use gradient for health (red to green)
    
    -- Tracers
    TracerEnabled = true,
    TracerColor = Color3fromRGB(255, 255, 255),
    TracerTransparency = 0.7,
    TracerThickness = 1,
    TracerOutline = true,
    TracerOutlineColor = Color3fromRGB(0, 0, 0),
    TracerOutlineTransparency = 0.5,
    TracerOrigin = "Bottom", -- "Bottom", "Center", "Mouse"
    TracerYOffset = 0, -- Additional Y offset
    TracerXOffset = 0, -- Additional X offset
    TracerStyle = "Line", -- "Line", "Dashed", "Dotted"
    TracerDashSize = 3, -- Size of dashes for dashed tracer
    TracerDashGap = 2, -- Gap between dashes
    
    -- Chams
    ChamsEnabled = true,
    ChamsColor = Color3fromRGB(255, 0, 0),
    ChamsTransparency = 0.5,
    ChamsOutlineColor = Color3fromRGB(0, 0, 0),
    ChamsOutlineTransparency = 0.5,
    ChamsUseTeamColor = false,
    ChamsVisibleOnly = false,
    ChamsHighlightMode = "Outline", -- "Outline", "Fill"
    
    -- Skeleton ESP
    SkeletonEnabled = true,
    SkeletonColor = Color3fromRGB(255, 255, 255),
    SkeletonTransparency = 0.7,
    SkeletonThickness = 1,
    SkeletonOutline = true,
    SkeletonOutlineColor = Color3fromRGB(0, 0, 0),
    SkeletonOutlineTransparency = 0.5,
    SkeletonStyle = "Line", -- "Line", "Dashed", "Dotted"
    SkeletonDashSize = 3, -- Size of dashes for dashed skeleton
    SkeletonDashGap = 2, -- Gap between dashes
    
    -- Head Dot
    HeadDotEnabled = true,
    HeadDotColor = Color3fromRGB(255, 0, 0),
    HeadDotTransparency = 0.7,
    HeadDotThickness = 1,
    HeadDotRadius = 3,
    HeadDotFilled = true,
    HeadDotOutline = true,
    HeadDotOutlineColor = Color3fromRGB(0, 0, 0),
    HeadDotOutlineTransparency = 0.5,
    HeadDotYOffset = 0, -- Additional Y offset
    HeadDotXOffset = 0, -- Additional X offset
    HeadDotPulse = false, -- Pulsing animation
    HeadDotPulseSpeed = 1, -- Speed of pulse
    HeadDotPulseSize = 1.5, -- Max size multiplier for pulse
    
    -- Tool ESP
    ToolEnabled = true,
    ToolColor = Color3fromRGB(255, 255, 255),
    ToolTransparency = 0.7,
    ToolOutline = true,
    ToolOutlineColor = Color3fromRGB(0, 0, 0),
    ToolOutlineTransparency = 0.5,
    ToolSize = 13,
    ToolFont = 2, -- Drawing.Fonts.UI
    ToolPosition = "bottom", -- top, bottom, left, right
    ToolYOffset = 30, -- Additional Y offset
    ToolXOffset = 0, -- Additional X offset
    
    -- State Display
    StateEnabled = true,
    StateColor = Color3fromRGB(255, 255, 255),
    StateTransparency = 0.7,
    StateOutline = true,
    StateOutlineColor = Color3fromRGB(0, 0, 0),
    StateOutlineTransparency = 0.5,
    StateSize = 13,
    StateFont = 2, -- Drawing.Fonts.UI
    StatePosition = "bottom", -- top, bottom, left, right
    StateYOffset = 45, -- Additional Y offset
    StateXOffset = 0, -- Additional X offset
    
    -- AimPoint
    AimPointEnabled = true,
    AimPointColor = Color3fromRGB(255, 0, 0),
    AimPointTransparency = 0.7,
    AimPointThickness = 1,
    AimPointRadius = 3,
    AimPointFilled = true,
    AimPointOutline = true,
    AimPointOutlineColor = Color3fromRGB(0, 0, 0),
    AimPointOutlineTransparency = 0.5,
    AimPointYOffset = 0, -- Additional Y offset
    AimPointXOffset = 0, -- Additional X offset
    AimPointPulse = true, -- Pulsing animation
    AimPointPulseSpeed = 1, -- Speed of pulse
    AimPointPulseSize = 1.5, -- Max size multiplier for pulse
    
    -- Hitbox Markers
    HitboxEnabled = true,
    HitboxColor = Color3fromRGB(255, 0, 0),
    HitboxTransparency = 0.7,
    HitboxThickness = 1,
    UseCustomHitboxPoints = false,
    CustomHitboxPoints = {
        Head = true,
        Torso = true,
        Arms = true,
        Legs = true
    },
    
    -- Colors
    TeamColor = true,
    EnemyColor = Color3fromRGB(255, 0, 0),
    TeamColorMode = "Team", -- "Team", "Custom"
    RainbowMode = false,
    RainbowSpeed = 1,
    
    -- Keybinds
    ToggleKey = Enum.KeyCode.RightShift,
    BoxToggleKey = Enum.KeyCode.One,
    NameToggleKey = Enum.KeyCode.Two,
    DistanceToggleKey = Enum.KeyCode.Three,
    HealthToggleKey = Enum.KeyCode.Four,
    TracerToggleKey = Enum.KeyCode.Five,
    ChamsToggleKey = Enum.KeyCode.Six,
    SkeletonToggleKey = Enum.KeyCode.Seven,
    HeadDotToggleKey = Enum.KeyCode.Eight,
    
    -- Lists
    Whitelist = {},
    Blacklist = {}
},

-- Internal
_rainbow = 0,
_pulse = 0,
_transitions = {}
}

-- Utility Functions
function ESP:IsAlive(player)
local character = player.Character
local humanoid = character and FindFirstChild(character, "Humanoid")
return character and humanoid and humanoid.Health > 0
end

function ESP:IsVisible(character, part)
if not self.Settings.VisibilityCheck then return true end

local origin = Camera.CFrame.Position
local target = part.Position
local direction = (target - origin).Unit * self.Settings.MaxDistance

local raycastParams = RaycastParamsnew()
raycastParams.FilterType = EnumRaycastFilterTypeBlacklist
raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, character}

local result = Workspace:Raycast(origin, direction, raycastParams)
return result == nil
end

function ESP:GetTeam(player)
return player.Team
end

function ESP:IsTeammate(player)
if not self.Settings.TeamCheck then return false end

local team = self:GetTeam(player)
local localTeam = self:GetTeam(LocalPlayer)

return team and localTeam and team == localTeam
end

function ESP:IsFriend(player)
if not self.Settings.IgnoreFriends then return false end
return LocalPlayer:IsFriendsWith(player.UserId)
end

function ESP:IsWhitelisted(player)
return tablefind(self.Settings.Whitelist, player.Name) or tablefind(self.Settings.Whitelist, player.UserId)
end

function ESP:IsBlacklisted(player)
return tablefind(self.Settings.Blacklist, player.Name) or tablefind(self.Settings.Blacklist, player.UserId)
end

function ESP:GetPlayerColor(player)
if self.Settings.RainbowMode then
    return Color3fromHSV(self._rainbow, 1, 1)
end

if self:IsTeammate(player) then
    if self.Settings.TeamColorMode == "Team" and player.Team and player.Team.TeamColor then
        return player.Team.TeamColor.Color
    else
        return self.Settings.TeamColor and Color3fromRGB(0, 255, 0) or self.Settings.BoxColor
    end
else
    return self.Settings.EnemyColor
end
end

function ESP:GetDistance(position)
return (Camera.CFrame.Position - position).Magnitude
end

function ESP:GetDistanceText(distance)
if distance < 10 then
    return stringformat("%.1f m", distance)
else
    return stringformat("%d m", mathfloor(distance))
end
end

function ESP:CalculateTransparency(distance)
if not self.Settings.FadeWithDistance then return 1 end

local maxDistance = self.Settings.MaxDistance
return mathclamp(1 - (distance / maxDistance), 0.1, 1)
end

function ESP:CalculateTextSize(distance)
if not self.Settings.DistanceTextSize then return self.Settings.NameSize end

local maxDistance = self.Settings.MaxDistance
local minSize = 8
local maxSize = self.Settings.NameSize

return mathclamp(maxSize - (distance / maxDistance) * (maxSize - minSize), minSize, maxSize)
end

function ESP:WorldToScreen(position)
local screenPosition, onScreen = WorldToViewportPoint(Camera, position)
return Vector2new(screenPosition.X, screenPosition.Y), onScreen, screenPosition.Z
end

-- Transition function for smooth animations
function ESP:Transition(id, current, target, speed)
if not self.Settings.SmoothTransitions then return target end

if not self._transitions[id] then
    self._transitions[id] = current
end

local transition = self._transitions[id]
local delta = (target - transition) * (speed or self.Settings.TransitionSpeed)

if mathabs(delta) < 0.01 then
    self._transitions[id] = target
else
    self._transitions[id] = transition + delta
end

return self._transitions[id]
end

-- Calculate position based on position type and box corners
function ESP:CalculatePosition(positionType, boxCorners, basePosition, xOffset, yOffset)
local position = basePosition

if boxCorners then
    local topLeft = boxCorners.TopLeft
    local bottomRight = boxCorners.BottomRight
    local boxSize = bottomRight - topLeft
    local boxCenter = topLeft + (boxSize / 2)
    
    if positionType == "top" then
        position = Vector2new(boxCenter.X + xOffset, topLeft.Y + yOffset)
    elseif positionType == "bottom" then
        position = Vector2new(boxCenter.X + xOffset, bottomRight.Y + yOffset)
    elseif positionType == "left" then
        position = Vector2new(topLeft.X + xOffset, boxCenter.Y + yOffset)
    elseif positionType == "right" then
        position = Vector2new(bottomRight.X + xOffset, boxCenter.Y + yOffset)
    end
else
    -- If no box corners, just apply the offsets
    position = Vector2new(position.X + xOffset, position.Y + yOffset)
end

return position
end

-- Improved function to get model bounds
function ESP:GetModelBounds(model)
if not model then return nil end

local parts = {}
local success, _ = pcall(function()
    if model:IsA("Model") then
        parts = model:GetDescendants()
    else
        parts = {model}
    end
end)

if not success then return nil end

local minX, minY, minZ = mathhuge, mathhuge, mathhuge
local maxX, maxY, maxZ = -mathhuge, -mathhuge, -mathhuge

local validParts = false

for _, part in pairs(parts) do
    if part:IsA("BasePart") then
        validParts = true
        
        local cf = part.CFrame
        local size = part.Size
        local corners = {
            cf * CFramenew(-size.X/2, -size.Y/2, -size.Z/2),
            cf * CFramenew(-size.X/2, -size.Y/2, size.Z/2),
            cf * CFramenew(-size.X/2, size.Y/2, -size.Z/2),
            cf * CFramenew(-size.X/2, size.Y/2, size.Z/2),
            cf * CFramenew(size.X/2, -size.Y/2, -size.Z/2),
            cf * CFramenew(size.X/2, -size.Y/2, size.Z/2),
            cf * CFramenew(size.X/2, size.Y/2, -size.Z/2),
            cf * CFramenew(size.X/2, size.Y/2, size.Z/2)
        }
        
        for _, corner in pairs(corners) do
            local pos = corner.Position
            
            minX = mathmin(minX, pos.X)
            minY = mathmin(minY, pos.Y)
            minZ = mathmin(minZ, pos.Z)
            
            maxX = mathmax(maxX, pos.X)
            maxY = mathmax(maxY, pos.Y)
            maxZ = mathmax(maxZ, pos.Z)
        end
    end
end

if not validParts then return nil end

local size = Vector3new(maxX - minX, maxY - minY, maxZ - minZ)
local position = Vector3new(minX + size.X/2, minY + size.Y/2, minZ + size.Z/2)

-- Apply padding
size = size + self.Settings.BoxPadding

return {
    Size = size,
    Position = position
}
end

function ESP:GetBoxCorners(object)
local bounds

if object:IsA("Model") or object:IsA("BasePart") then
    bounds = self:GetModelBounds(object)
    if not bounds then return nil end
else
    return nil
end

local size = bounds.Size
local position = bounds.Position

-- Calculate the camera-facing orientation
local cameraPosition = Camera.CFrame.Position
local lookVector = (position - cameraPosition).Unit

-- Create a CFrame that faces the camera
local right = lookVector:Cross(Vector3new(0, 1, 0)).Unit
local up = right:Cross(lookVector).Unit
local cf = CFramenew(
    position.X, position.Y, position.Z,
    right.X, up.X, -lookVector.X,
    right.Y, up.Y, -lookVector.Y,
    right.Z, up.Z, -lookVector.Z
)

-- Calculate corners that always face the camera
local halfSizeX = size.X / 2
local halfSizeY = size.Y / 2

local tl = cf * CFramenew(-halfSizeX, halfSizeY, 0)
local tr = cf * CFramenew(halfSizeX, halfSizeY, 0)
local bl = cf * CFramenew(-halfSizeX, -halfSizeY, 0)
local br = cf * CFramenew(halfSizeX, -halfSizeY, 0)

local tlp, tls, _ = self:WorldToScreen(tl.Position)
local trp, trs, _ = self:WorldToScreen(tr.Position)
local blp, bls, _ = self:WorldToScreen(bl.Position)
local brp, brs, _ = self:WorldToScreen(br.Position)

if not (tls and trs and bls and brs) then return nil end

return {
    TopLeft = tlp,
    TopRight = trp,
    BottomLeft = blp,
    BottomRight = brp
}
end

function ESP:Get3DBoxCorners(object)
local bounds

if object:IsA("Model") or object:IsA("BasePart") then
    bounds = self:GetModelBounds(object)
    if not bounds then return nil end
else
    return nil
end

local size = bounds.Size
local position = bounds.Position

-- Calculate the camera-facing orientation
local cameraPosition = Camera.CFrame.Position
local lookVector = (position - cameraPosition).Unit

-- Create a CFrame that faces the camera
local right = lookVector:Cross(Vector3new(0, 1, 0)).Unit
local up = right:Cross(lookVector).Unit
local cf = CFramenew(
    position.X, position.Y, position.Z,
    right.X, up.X, -lookVector.X,
    right.Y, up.Y, -lookVector.Y,
    right.Z, up.Z, -lookVector.Z
)

-- Define all 8 corners of the 3D box
local halfSizeX = size.X / 2
local halfSizeY = size.Y / 2
local halfSizeZ = size.Z / 2

local corners = {
    -- Front face (facing camera)
    cf * CFramenew(-halfSizeX, halfSizeY, -halfSizeZ),
    cf * CFramenew(halfSizeX, halfSizeY, -halfSizeZ),
    cf * CFramenew(-halfSizeX, -halfSizeY, -halfSizeZ),
    cf * CFramenew(halfSizeX, -halfSizeY, -halfSizeZ),
    
    -- Back face
    cf * CFramenew(-halfSizeX, halfSizeY, halfSizeZ),
    cf * CFramenew(halfSizeX, halfSizeY, halfSizeZ),
    cf * CFramenew(-halfSizeX, -halfSizeY, halfSizeZ),
    cf * CFramenew(halfSizeX, -halfSizeY, halfSizeZ)
}

local screenCorners = {}
local allOnScreen = true

for i, corner in ipairs(corners) do
    local screenPosition, onScreen, _ = self:WorldToScreen(corner.Position)
    screenCorners[i] = screenPosition
    
    if not onScreen then
        allOnScreen = false
    end
end

if not allOnScreen then return nil end

return screenCorners
end

function ESP:GetCornerBoxPoints(boxCorners)
if not boxCorners then return nil end

local topLeft = boxCorners.TopLeft
local topRight = boxCorners.TopRight
local bottomLeft = boxCorners.BottomLeft
local bottomRight = boxCorners.BottomRight

local width = (topRight - topLeft).Magnitude
local height = (bottomLeft - topLeft).Magnitude
local cornerSize = mathmin(self.Settings.CornerSize, width / 3, height / 3)

local points = {
    -- Top Left Corner
    {topLeft, topLeft + Vector2new(cornerSize, 0)}, -- Horizontal
    {topLeft, topLeft + Vector2new(0, cornerSize)}, -- Vertical
    
    -- Top Right Corner
    {topRight, topRight - Vector2new(cornerSize, 0)}, -- Horizontal
    {topRight, topRight + Vector2new(0, cornerSize)}, -- Vertical
    
    -- Bottom Left Corner
    {bottomLeft, bottomLeft + Vector2new(cornerSize, 0)}, -- Horizontal
    {bottomLeft, bottomLeft - Vector2new(0, cornerSize)}, -- Vertical
    
    -- Bottom Right Corner
    {bottomRight, bottomRight - Vector2new(cornerSize, 0)}, -- Horizontal
    {bottomRight, bottomRight - Vector2new(0, cornerSize)}  -- Vertical
}

return points
end

function ESP:GetSkeletonPoints(character)
local points = {}
local allOnScreen = true

-- Define the skeleton connections
local connections = {
    {"Head", "Neck" or "UpperTorso" or "Torso"},
    {"Neck" or "UpperTorso" or "Torso", "UpperTorso" or "Torso"},
    {"UpperTorso" or "Torso", "LowerTorso" or "Torso"},
    {"LowerTorso" or "Torso", "RightUpperLeg" or "Right Leg"},
    {"LowerTorso" or "Torso", "LeftUpperLeg" or "Left Leg"},
    {"RightUpperLeg" or "Right Leg", "RightLowerLeg" or "Right Leg"},
    {"LeftUpperLeg" or "Left Leg", "LeftLowerLeg" or "Left Leg"},
    {"RightLowerLeg" or "Right Leg", "RightFoot" or "Right Leg"},
    {"LeftLowerLeg" or "Left Leg", "LeftFoot" or "Left Leg"},
    {"UpperTorso" or "Torso", "RightUpperArm" or "Right Arm"},
    {"UpperTorso" or "Torso", "LeftUpperArm" or "Left Arm"},
    {"RightUpperArm" or "Right Arm", "RightLowerArm" or "Right Arm"},
    {"LeftUpperArm" or "Left Arm", "LeftLowerArm" or "Left Arm"},
    {"RightLowerArm" or "Right Arm", "RightHand" or "Right Arm"},
    {"LeftLowerArm" or "Left Arm", "LeftHand" or "Left Arm"}
}

for _, connection in ipairs(connections) do
    local part1 = FindFirstChild(character, connection[1])
    local part2 = FindFirstChild(character, connection[2])
    
    if part1 and part2 then
        local p1, onScreen1, _ = self:WorldToScreen(part1.Position)
        local p2, onScreen2, _ = self:WorldToScreen(part2.Position)
        
        if onScreen1 and onScreen2 then
            tableinsert(points, {p1, p2})
        else
            allOnScreen = false
        end
    end
end

if not allOnScreen then return nil end

return points
end

function ESP:GetHitboxPoints(character)
local points = {}
local allOnScreen = true

local hitboxParts = {
    Head = FindFirstChild(character, "Head"),
    Torso = FindFirstChild(character, "UpperTorso") or FindFirstChild(character, "Torso"),
    Arms = {
        FindFirstChild(character, "RightUpperArm") or FindFirstChild(character, "Right Arm"),
        FindFirstChild(character, "LeftUpperArm") or FindFirstChild(character, "Left Arm")
    },
    Legs = {
        FindFirstChild(character, "RightUpperLeg") or FindFirstChild(character, "Right Leg"),
        FindFirstChild(character, "LeftUpperLeg") or FindFirstChild(character, "Left Leg")
    }
}

for partName, part in pairs(hitboxParts) do
    if self.Settings.CustomHitboxPoints[partName] then
        if type(part) == "table" then
            for _, p in ipairs(part) do
                if p then
                    local screenPos, onScreen, _ = self:WorldToScreen(p.Position)
                    if onScreen then
                        tableinsert(points, screenPos)
                    else
                        allOnScreen = false
                    end
                end
            end
        elseif part then
            local screenPos, onScreen, _ = self:WorldToScreen(part.Position)
            if onScreen then
                tableinsert(points, screenPos)
            else
                allOnScreen = false
            end
        end
    end
end

if not allOnScreen then return nil end

return points
end

-- Function to check if a character is invisible
function ESP:IsCharacterInvisible(character)
if not character then return false end

-- Check if any parts are visible
for _, part in pairs(character:GetChildren()) do
    if part:IsA("BasePart") and part.Transparency < 0.9 then
        return false
    end
end

return true
end

-- Drawing Functions
function ESP:CreateDrawing(type, properties)
local drawing = Drawingnew(type)

for property, value in pairs(properties) do
    drawing[property] = value
end

tableinsert(self.Drawings, drawing)

return drawing
end

function ESP:RemoveDrawing(drawing)
if drawing then
    drawing:Remove()
    
    for i, d in ipairs(self.Drawings) do
        if d == drawing then
            tableremove(self.Drawings, i)
            break
        end
    end
end
end

function ESP:ClearDrawings()
for _, drawing in ipairs(self.Drawings) do
    drawing:Remove()
end

self.Drawings = {}
end

-- Draw dashed line
function ESP:DrawDashedLine(from, to, dashSize, gapSize, color, thickness, transparency, zIndex)
local direction = (to - from).Unit
local distance = (to - from).Magnitude
local dashCount = mathfloor(distance / (dashSize + gapSize))
local lines = {}

for i = 0, dashCount do
    local startPos = from + direction * (i * (dashSize + gapSize))
    local endPos = startPos + direction * mathmin(dashSize, distance - i * (dashSize + gapSize))
    
    if (endPos - startPos).Magnitude > 0 then
        local line = self:CreateDrawing("Line", {
            Visible = true,
            From = startPos,
            To = endPos,
            Color = color,
            Thickness = thickness,
            Transparency = transparency,
            ZIndex = zIndex
        })
        
        tableinsert(lines, line)
    end
end

return lines
end

-- ESP Functions
function ESP:CreatePlayerESP(player)
if not player or player == LocalPlayer then return end

local playerData = {
    Player = player,
    Drawings = {
        Box = self:CreateDrawing("Square", {
            Visible = false,
            Color = self.Settings.BoxColor,
            Thickness = self.Settings.BoxThickness,
            Transparency = self.Settings.BoxTransparency,
            Filled = self.Settings.BoxFilled,
            ZIndex = self.Settings.ZIndex
        }),
        BoxOutline = self:CreateDrawing("Square", {
            Visible = false,
            Color = self.Settings.BoxOutlineColor,
            Thickness = self.Settings.BoxThickness + 2,
            Transparency = self.Settings.BoxOutlineTransparency,
            Filled = false,
            ZIndex = self.Settings.ZIndex - 1
        }),
        BoxFill = self:CreateDrawing("Square", {
            Visible = false,
            Color = self.Settings.BoxColor,
            Transparency = self.Settings.BoxFilledTransparency,
            Filled = true,
            ZIndex = self.Settings.ZIndex - 2
        }),
        BoxCorners = {},
        Box3D = {},
        Name = self:CreateDrawing("Text", {
            Visible = false,
            Color = self.Settings.NameColor,
            Transparency = self.Settings.NameTransparency,
            Size = self.Settings.NameSize,
            Center = true,
            Outline = self.Settings.NameOutline,
            OutlineColor = self.Settings.NameOutlineColor,
            Font = self.Settings.NameFont,
            ZIndex = self.Settings.ZIndex
        }),
        Distance = self:CreateDrawing("Text", {
            Visible = false,
            Color = self.Settings.DistanceColor,
            Transparency = self.Settings.DistanceTransparency,
            Size = self.Settings.DistanceSize,
            Center = true,
            Outline = self.Settings.DistanceOutline,
            OutlineColor = self.Settings.DistanceOutlineColor,
            Font = self.Settings.DistanceFont,
            ZIndex = self.Settings.ZIndex
        }),
        HealthBar = self:CreateDrawing("Square", {
            Visible = false,
            Color = self.Settings.HealthColor,
            Thickness = self.Settings.HealthThickness,
            Transparency = self.Settings.HealthTransparency,
            Filled = true,
            ZIndex = self.Settings.ZIndex
        }),
        HealthBarOutline = self:CreateDrawing("Square", {
            Visible = false,
            Color = self.Settings.HealthOutlineColor,
            Thickness = 1,
            Transparency = self.Settings.HealthOutlineTransparency,
            Filled = false,
            ZIndex = self.Settings.ZIndex - 1
        }),
        Tracer = self:CreateDrawing("Line", {
            Visible = false,
            Color = self.Settings.TracerColor,
            Thickness = self.Settings.TracerThickness,
            Transparency = self.Settings.TracerTransparency,
            ZIndex = self.Settings.ZIndex
        }),
        TracerOutline = self:CreateDrawing("Line", {
            Visible = false,
            Color = self.Settings.TracerOutlineColor,
            Thickness = self.Settings.TracerThickness + 2,
            Transparency = self.Settings.TracerOutlineTransparency,
            ZIndex = self.Settings.ZIndex - 1
        }),
        TracerDashed = {},
        HeadDot = self:CreateDrawing("Circle", {
            Visible = false,
            Color = self.Settings.HeadDotColor,
            Thickness = self.Settings.HeadDotThickness,
            Transparency = self.Settings.HeadDotTransparency,
            NumSides = 30,
            Filled = self.Settings.HeadDotFilled,
            Radius = self.Settings.HeadDotRadius,
            ZIndex = self.Settings.ZIndex
        }),
        HeadDotOutline = self:CreateDrawing("Circle", {
            Visible = false,
            Color = self.Settings.HeadDotOutlineColor,
            Thickness = self.Settings.HeadDotThickness + 2,
            Transparency = self.Settings.HeadDotOutlineTransparency,
            NumSides = 30,
            Filled = false,
            Radius = self.Settings.HeadDotRadius,
            ZIndex = self.Settings.ZIndex - 1
        }),
        Tool = self:CreateDrawing("Text", {
            Visible = false,
            Color = self.Settings.ToolColor,
            Transparency = self.Settings.ToolTransparency,
            Size = self.Settings.ToolSize,
            Center = true,
            Outline = self.Settings.ToolOutline,
            OutlineColor = self.Settings.ToolOutlineColor,
            Font = self.Settings.ToolFont,
            ZIndex = self.Settings.ZIndex
        }),
        State = self:CreateDrawing("Text", {
            Visible = false,
            Color = self.Settings.StateColor,
            Transparency = self.Settings.StateTransparency,
            Size = self.Settings.StateSize,
            Center = true,
            Outline = self.Settings.StateOutline,
            OutlineColor = self.Settings.StateOutlineColor,
            Font = self.Settings.StateFont,
            ZIndex = self.Settings.ZIndex
        }),
        AimPoint = self:CreateDrawing("Circle", {
            Visible = false,
            Color = self.Settings.AimPointColor,
            Thickness = self.Settings.AimPointThickness,
            Transparency = self.Settings.AimPointTransparency,
            NumSides = 30,
            Filled = self.Settings.AimPointFilled,
            Radius = self.Settings.AimPointRadius,
            ZIndex = self.Settings.ZIndex
        }),
        AimPointOutline = self:CreateDrawing("Circle", {
            Visible = false,
            Color = self.Settings.AimPointOutlineColor,
            Thickness = self.Settings.AimPointThickness + 2,
            Transparency = self.Settings.AimPointOutlineTransparency,
            NumSides = 30,
            Filled = false,
            Radius = self.Settings.AimPointRadius,
            ZIndex = self.Settings.ZIndex - 1
        }),
        Skeleton = {},
        SkeletonDashed = {},
        Hitbox = {}
    }
}

-- Create corner box lines
for i = 1, 8 do
    playerData.Drawings.BoxCorners[i] = {
        Line = self:CreateDrawing("Line", {
            Visible = false,
            Color = self.Settings.BoxColor,
            Thickness = self.Settings.BoxThickness,
            Transparency = self.Settings.BoxTransparency,
            ZIndex = self.Settings.ZIndex
        }),
        Outline = self:CreateDrawing("Line", {
            Visible = false,
            Color = self.Settings.BoxOutlineColor,
            Thickness = self.Settings.BoxThickness + 2,
            Transparency = self.Settings.BoxOutlineTransparency,
            ZIndex = self.Settings.ZIndex - 1
        })
    }
end

-- Create 3D box lines
for i = 1, 12 do
    playerData.Drawings.Box3D[i] = {
        Line = self:CreateDrawing("Line", {
            Visible = false,
            Color = self.Settings.BoxColor,
            Thickness = self.Settings.BoxThickness,
            Transparency = self.Settings.BoxTransparency,
            ZIndex = self.Settings.ZIndex
        }),
        Outline = self:CreateDrawing("Line", {
            Visible = false,
            Color = self.Settings.BoxOutlineColor,
            Thickness = self.Settings.BoxThickness + 2,
            Transparency = self.Settings.BoxOutlineTransparency,
            ZIndex = self.Settings.ZIndex - 1
        })
    }
end

-- Create skeleton lines
for i = 1, 15 do
    playerData.Drawings.Skeleton[i] = {
        Line = self:CreateDrawing("Line", {
            Visible = false,
            Color = self.Settings.SkeletonColor,
            Thickness = self.Settings.SkeletonThickness,
            Transparency = self.Settings.SkeletonTransparency,
            ZIndex = self.Settings.ZIndex
        }),
        Outline = self:CreateDrawing("Line", {
            Visible = false,
            Color = self.Settings.SkeletonOutlineColor,
            Thickness = self.Settings.SkeletonThickness + 2,
            Transparency = self.Settings.SkeletonOutlineTransparency,
            ZIndex = self.Settings.ZIndex - 1
        })
    }
end

-- Create hitbox markers
for i = 1, 10 do
    playerData.Drawings.Hitbox[i] = self:CreateDrawing("Circle", {
        Visible = false,
        Color = self.Settings.HitboxColor,
        Thickness = self.Settings.HitboxThickness,
        Transparency = self.Settings.HitboxTransparency,
        NumSides = 30,
        Filled = true,
        Radius = 2,
        ZIndex = self.Settings.ZIndex
    })
end

self.Players[player] = playerData
return playerData
end

function ESP:RemovePlayerESP(player)
local playerData = self.Players[player]

if playerData then
    for _, drawing in pairs(playerData.Drawings) do
        if type(drawing) == "table" then
            if drawing.Line then
                self:RemoveDrawing(drawing.Line)
                self:RemoveDrawing(drawing.Outline)
            else
                for _, subDrawing in pairs(drawing) do
                    if type(subDrawing) == "table" then
                        self:RemoveDrawing(subDrawing.Line)
                        self:RemoveDrawing(subDrawing.Outline)
                    else
                        self:RemoveDrawing(subDrawing)
                    end
                end
            end
        else
            self:RemoveDrawing(drawing)
        end
    end
    
    self.Players[player] = nil
end
end

function ESP:UpdatePlayerESP(player)
local playerData = self.Players[player]
if not playerData then return end

local character = player.Character
if not character then return end

local humanoid = FindFirstChild(character, "Humanoid")
local hrp = FindFirstChild(character, "HumanoidRootPart")
local head = FindFirstChild(character, "Head")

if not (humanoid and hrp and head) then return end

-- Check if player should be rendered
if self.Settings.IgnoreDead and humanoid.Health <= 0 then return end
if self.Settings.IgnoreInvisible and self:IsCharacterInvisible(character) then return end
if self:IsBlacklisted(player) then return end
if self.Settings.Whitelist and #self.Settings.Whitelist > 0 and not self:IsWhitelisted(player) then return end
if self:IsFriend(player) then return end

-- Get player position and check distance
local position = hrp.Position
local distance = self:GetDistance(position)

if distance > self.Settings.MaxDistance then
    for _, drawing in pairs(playerData.Drawings) do
        if type(drawing) == "table" then
            if drawing.Line then
                drawing.Line.Visible = false
                drawing.Outline.Visible = false
            else
                for _, subDrawing in pairs(drawing) do
                    if type(subDrawing) == "table" then
                        subDrawing.Line.Visible = false
                        subDrawing.Outline.Visible = false
                    else
                        subDrawing.Visible = false
                    end
                end
            end
        else
            drawing.Visible = false
        end
    end
    return
end

-- Check visibility
local isVisible = self:IsVisible(character, head)
local transparency = self:CalculateTransparency(distance)
if self.Settings.VisibilityFade and not isVisible then
    transparency = transparency * 0.5
end

-- Get player color
local color = self:GetPlayerColor(player)

-- Update box ESP
if self.Settings.BoxEnabled then
    local boxCorners = self:GetBoxCorners(character)
    
    -- Hide all box types first
    playerData.Drawings.Box.Visible = false
    playerData.Drawings.BoxOutline.Visible = false
    playerData.Drawings.BoxFill.Visible = false
    
    for _, corner in pairs(playerData.Drawings.BoxCorners) do
        corner.Line.Visible = false
        corner.Outline.Visible = false
    end
    
    for _, line in pairs(playerData.Drawings.Box3D) do
        line.Line.Visible = false
        line.Outline.Visible = false
    end
    
    if boxCorners then
        local topLeft = boxCorners.TopLeft
        local bottomRight = boxCorners.BottomRight
        local boxSize = bottomRight - topLeft
        
        if self.Settings.BoxType == "2D" then
            playerData.Drawings.Box.Position = topLeft
            playerData.Drawings.Box.Size = boxSize
            playerData.Drawings.Box.Color = color
            playerData.Drawings.Box.Transparency = transparency * self.Settings.BoxTransparency
            playerData.Drawings.Box.Visible = true
            
            if self.Settings.BoxOutline then
                playerData.Drawings.BoxOutline.Position = topLeft
                playerData.Drawings.BoxOutline.Size = boxSize
                playerData.Drawings.BoxOutline.Transparency = transparency * self.Settings.BoxOutlineTransparency
                playerData.Drawings.BoxOutline.Visible = true
            end
            
            if self.Settings.BoxFilled then
                playerData.Drawings.BoxFill.Position = topLeft
                playerData.Drawings.BoxFill.Size = boxSize
                playerData.Drawings.BoxFill.Color = color
                playerData.Drawings.BoxFill.Transparency = transparency * self.Settings.BoxFilledTransparency
                playerData.Drawings.BoxFill.Visible = true
            end
        elseif self.Settings.BoxType == "Corner" then
            local cornerPoints = self:GetCornerBoxPoints(boxCorners)
            
            if cornerPoints then
                for i, points in ipairs(cornerPoints) do
                    if i <= #playerData.Drawings.BoxCorners then
                        playerData.Drawings.BoxCorners[i].Line.From = points[1]
                        playerData.Drawings.BoxCorners[i].Line.To = points[2]
                        playerData.Drawings.BoxCorners[i].Line.Color = color
                        playerData.Drawings.BoxCorners[i].Line.Transparency = transparency * self.Settings.BoxTransparency
                        playerData.Drawings.BoxCorners[i].Line.Visible = true
                        
                        if self.Settings.BoxOutline then
                            playerData.Drawings.BoxCorners[i].Outline.From = points[1]
                            playerData.Drawings.BoxCorners[i].Outline.To = points[2]
                            playerData.Drawings.BoxCorners[i].Outline.Transparency = transparency * self.Settings.BoxOutlineTransparency
                            playerData.Drawings.BoxCorners[i].Outline.Visible = true
                        end
                    end
                end
            end
        elseif self.Settings.BoxType == "3D" then
            local corners3D = self:Get3DBoxCorners(character)
            
            if corners3D then
                -- Define the 12 edges of a 3D box
                local edges = {
                    -- Top square
                    {1, 2}, {2, 4}, {4, 3}, {3, 1},
                    -- Bottom square
                    {5, 6}, {6, 8}, {8, 7}, {7, 5},
                    -- Connecting lines
                    {1, 5}, {2, 6}, {3, 7}, {4, 8}
                }
                
                for i, edge in ipairs(edges) do
                    if i <= #playerData.Drawings.Box3D then
                        playerData.Drawings.Box3D[i].Line.From = corners3D[edge[1]]
                        playerData.Drawings.Box3D[i].Line.To = corners3D[edge[2]]
                        playerData.Drawings.Box3D[i].Line.Color = color
                        playerData.Drawings.Box3D[i].Line.Transparency = transparency * self.Settings.BoxTransparency
                        playerData.Drawings.Box3D[i].Line.Visible = true
                        
                        if self.Settings.BoxOutline then
                            playerData.Drawings.Box3D[i].Outline.From = corners3D[edge[1]]
                            playerData.Drawings.Box3D[i].Outline.To = corners3D[edge[2]]
                            playerData.Drawings.Box3D[i].Outline.Transparency = transparency * self.Settings.BoxOutlineTransparency
                            playerData.Drawings.Box3D[i].Outline.Visible = true
                        end
                    end
                end
            end
        end
    end
else
    playerData.Drawings.Box.Visible = false
    playerData.Drawings.BoxOutline.Visible = false
    playerData.Drawings.BoxFill.Visible = false
    
    for _, corner in pairs(playerData.Drawings.BoxCorners) do
        corner.Line.Visible = false
        corner.Outline.Visible = false
    end
    
    for _, line in pairs(playerData.Drawings.Box3D) do
        line.Line.Visible = false
        line.Outline.Visible = false
    end
end

-- Update name ESP
if self.Settings.NameEnabled then
    local headPos, onScreen, depth = self:WorldToScreen(head.Position)
    local boxCorners = self:GetBoxCorners(character)
    
    if onScreen then
        local displayName = self.Settings.UseDisplayName and player.DisplayName or player.Name
        local textSize = self:CalculateTextSize(distance)
        local namePosition = self:CalculatePosition(
            self.Settings.NamePosition, 
            boxCorners, 
            headPos, 
            self.Settings.NameXOffset, 
            self.Settings.NameYOffset
        )
        
        playerData.Drawings.Name.Position = namePosition
        playerData.Drawings.Name.Text = displayName
        playerData.Drawings.Name.Color = color
        playerData.Drawings.Name.Transparency = transparency * self.Settings.NameTransparency
        playerData.Drawings.Name.Size = textSize
        playerData.Drawings.Name.Visible = true
    else
        playerData.Drawings.Name.Visible = false
    end
else
    playerData.Drawings.Name.Visible = false
end

-- Update distance ESP
if self.Settings.DistanceEnabled then
    local headPos, onScreen, depth = self:WorldToScreen(head.Position)
    local boxCorners = self:GetBoxCorners(character)
    
    if onScreen then
        local distanceText = self:GetDistanceText(distance)
        local textSize = self:CalculateTextSize(distance)
        local distancePosition = self:CalculatePosition(
            self.Settings.DistancePosition, 
            boxCorners, 
            headPos, 
            self.Settings.DistanceXOffset, 
            self.Settings.DistanceYOffset
        )
        
        playerData.Drawings.Distance.Position = distancePosition
        playerData.Drawings.Distance.Text = distanceText
        playerData.Drawings.Distance.Color = color
        playerData.Drawings.Distance.Transparency = transparency * self.Settings.DistanceTransparency
        playerData.Drawings.Distance.Size = textSize
        playerData.Drawings.Distance.Visible = true
    else
        playerData.Drawings.Distance.Visible = false
    end
else
    playerData.Drawings.Distance.Visible = false
end

-- Update health ESP
if self.Settings.HealthEnabled then
    local boxCorners = self:GetBoxCorners(character)
    
    if boxCorners and humanoid then
        local topLeft = boxCorners.TopLeft
        local bottomRight = boxCorners.BottomRight
        local boxSize = bottomRight - topLeft
        
        local healthPercent = mathclamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
        local healthColor
        
        if self.Settings.HealthGradient then
            healthColor = Color3fromRGB(
                255 * (1 - healthPercent),
                255 * healthPercent,
                0
            )
        else
            healthColor = self.Settings.HealthColor
        end
        
        if self.Settings.HealthType == "Vertical" then
            local barHeight = boxSize.Y * healthPercent
            local barWidth = self.Settings.HealthBarThickness
            local healthPosition
            
            if self.Settings.HealthPosition == "left" then
                healthPosition = Vector2new(
                    topLeft.X + self.Settings.HealthXOffset - barWidth,
                    bottomRight.Y - barHeight + self.Settings.HealthYOffset
                )
            elseif self.Settings.HealthPosition == "right" then
                healthPosition = Vector2new(
                    bottomRight.X + self.Settings.HealthXOffset,
                    bottomRight.Y - barHeight + self.Settings.HealthYOffset
                )
            else
                healthPosition = Vector2new(
                    topLeft.X + self.Settings.HealthXOffset - barWidth,
                    bottomRight.Y - barHeight + self.Settings.HealthYOffset
                )
            end
            
            playerData.Drawings.HealthBar.Position = healthPosition
            playerData.Drawings.HealthBar.Size = Vector2new(barWidth, barHeight)
            playerData.Drawings.HealthBarOutline.Position = Vector2new(
                healthPosition.X,
                topLeft.Y + self.Settings.HealthYOffset
            )
            playerData.Drawings.HealthBarOutline.Size = Vector2new(barWidth, boxSize.Y)
        else -- Horizontal
            local barWidth = boxSize.X * healthPercent
            local barHeight = self.Settings.HealthBarThickness
            local healthPosition
            
            if self.Settings.HealthPosition == "top" then
                healthPosition = Vector2new(
                    topLeft.X + self.Settings.HealthXOffset,
                    topLeft.Y + self.Settings.HealthYOffset - barHeight
                )
            elseif self.Settings.HealthPosition == "bottom" then
                healthPosition = Vector2new(
                    topLeft.X + self.Settings.HealthXOffset,
                    bottomRight.Y + self.Settings.HealthYOffset
                )
            else
                healthPosition = Vector2new(
                    topLeft.X + self.Settings.HealthXOffset,
                    bottomRight.Y + self.Settings.HealthYOffset
                )
            end
            
            playerData.Drawings.HealthBar.Position = healthPosition
            playerData.Drawings.HealthBar.Size = Vector2new(barWidth, barHeight)
            playerData.Drawings.HealthBarOutline.Position = healthPosition
            playerData.Drawings.HealthBarOutline.Size = Vector2new(boxSize.X, barHeight)
        end
        
        playerData.Drawings.HealthBar.Color = healthColor
        playerData.Drawings.HealthBar.Transparency = transparency * self.Settings.HealthTransparency
        playerData.Drawings.HealthBar.Visible = true
        
        if self.Settings.HealthOutline then
            playerData.Drawings.HealthBarOutline.Transparency = transparency * self.Settings.HealthOutlineTransparency
            playerData.Drawings.HealthBarOutline.Visible = true
        else
            playerData.Drawings.HealthBarOutline.Visible = false
        end
    else
        playerData.Drawings.HealthBar.Visible = false
        playerData.Drawings.HealthBarOutline.Visible = false
    end
else
    playerData.Drawings.HealthBar.Visible = false
    playerData.Drawings.HealthBarOutline.Visible = false
end

-- Update tracer ESP
if self.Settings.TracerEnabled then
    local hrpPos, onScreen, depth = self:WorldToScreen(hrp.Position)
    
    if onScreen then
        local from
        
        if self.Settings.TracerOrigin == "Bottom" then
            from = Vector2new(Camera.ViewportSize.X / 2 + self.Settings.TracerXOffset, Camera.ViewportSize.Y + self.Settings.TracerYOffset)
        elseif self.Settings.TracerOrigin == "Center" then
            from = Vector2new(Camera.ViewportSize.X / 2 + self.Settings.TracerXOffset, Camera.ViewportSize.Y / 2 + self.Settings.TracerYOffset)
        elseif self.Settings.TracerOrigin == "Mouse" then
            from = UserInputService:GetMouseLocation() + Vector2new(self.Settings.TracerXOffset, self.Settings.TracerYOffset)
        end
        
        -- Clear any existing dashed tracers
        for _, line in pairs(playerData.Drawings.TracerDashed) do
            self:RemoveDrawing(line)
        end
        playerData.Drawings.TracerDashed = {}
        
        if self.Settings.TracerStyle == "Line" then
            playerData.Drawings.Tracer.From = from
            playerData.Drawings.Tracer.To = hrpPos
            playerData.Drawings.Tracer.Color = color
            playerData.Drawings.Tracer.Transparency = transparency * self.Settings.TracerTransparency
            playerData.Drawings.Tracer.Visible = true
            
            if self.Settings.TracerOutline then
                playerData.Drawings.TracerOutline.From = from
                playerData.Drawings.TracerOutline.To = hrpPos
                playerData.Drawings.TracerOutline.Transparency = transparency * self.Settings.TracerOutlineTransparency
                playerData.Drawings.TracerOutline.Visible = true
            else
                playerData.Drawings.TracerOutline.Visible = false
            end
        elseif self.Settings.TracerStyle == "Dashed" or self.Settings.TracerStyle == "Dotted" then
            playerData.Drawings.Tracer.Visible = false
            playerData.Drawings.TracerOutline.Visible = false
            
            local dashSize = self.Settings.TracerStyle == "Dotted" and 1 or self.Settings.TracerDashSize
            local gapSize = self.Settings.TracerDashGap
            
            playerData.Drawings.TracerDashed = self:DrawDashedLine(
                from, 
                hrpPos, 
                dashSize, 
                gapSize, 
                color, 
                self.Settings.TracerThickness, 
                transparency * self.Settings.TracerTransparency, 
                self.Settings.ZIndex
            )
        end
    else
        playerData.Drawings.Tracer.Visible = false
        playerData.Drawings.TracerOutline.Visible = false
        
        for _, line in pairs(playerData.Drawings.TracerDashed) do
            line.Visible = false
        end
    end
else
    playerData.Drawings.Tracer.Visible = false
    playerData.Drawings.TracerOutline.Visible = false
    
    for _, line in pairs(playerData.Drawings.TracerDashed) do
        line.Visible = false
    end
end

-- Update head dot ESP
if self.Settings.HeadDotEnabled then
    local headPos, onScreen, depth = self:WorldToScreen(head.Position)
    
    if onScreen then
        local headDotPosition = Vector2new(
            headPos.X + self.Settings.HeadDotXOffset,
            headPos.Y + self.Settings.HeadDotYOffset
        )
        
        local radius = self.Settings.HeadDotRadius
        
        if self.Settings.HeadDotPulse then
            local pulse = (mathsin(self._pulse * self.Settings.HeadDotPulseSpeed) + 1) / 2
            radius = radius * (1 + pulse * (self.Settings.HeadDotPulseSize - 1))
        end
        
        playerData.Drawings.HeadDot.Position = headDotPosition
        playerData.Drawings.HeadDot.Color = color
        playerData.Drawings.HeadDot.Transparency = transparency * self.Settings.HeadDotTransparency
        playerData.Drawings.HeadDot.Radius = radius
        playerData.Drawings.HeadDot.Visible = true
        
        if self.Settings.HeadDotOutline then
            playerData.Drawings.HeadDotOutline.Position = headDotPosition
            playerData.Drawings.HeadDotOutline.Transparency = transparency * self.Settings.HeadDotOutlineTransparency
            playerData.Drawings.HeadDotOutline.Radius = radius
            playerData.Drawings.HeadDotOutline.Visible = true
        else
            playerData.Drawings.HeadDotOutline.Visible = false
        end
    else
        playerData.Drawings.HeadDot.Visible = false
        playerData.Drawings.HeadDotOutline.Visible = false
    end
else
    playerData.Drawings.HeadDot.Visible = false
    playerData.Drawings.HeadDotOutline.Visible = false
end

-- Update tool ESP
if self.Settings.ToolEnabled then
    local headPos, onScreen, depth = self:WorldToScreen(head.Position)
    local boxCorners = self:GetBoxCorners(character)
    
    if onScreen then
        local tool = character:FindFirstChildOfClass("Tool")
        local toolName = tool and tool.Name or "None"
        local toolPosition = self:CalculatePosition(
            self.Settings.ToolPosition, 
            boxCorners, 
            headPos, 
            self.Settings.ToolXOffset, 
            self.Settings.ToolYOffset
        )
        
        playerData.Drawings.Tool.Position = toolPosition
        playerData.Drawings.Tool.Text = "Tool: " .. toolName
        playerData.Drawings.Tool.Color = color
        playerData.Drawings.Tool.Transparency = transparency * self.Settings.ToolTransparency
        playerData.Drawings.Tool.Visible = true
    else
        playerData.Drawings.Tool.Visible = false
    end
else
    playerData.Drawings.Tool.Visible = false
end

-- Update state ESP
if self.Settings.StateEnabled then
    local headPos, onScreen, depth = self:WorldToScreen(head.Position)
    local boxCorners = self:GetBoxCorners(character)
    
    if onScreen then
        local state = "Standing"
        
        if humanoid.Health <= 0 then
            state = "Dead"
        elseif humanoid.PlatformStand then
            state = "Stunned"
        elseif humanoid:GetState() == Enum.HumanoidStateType.Climbing then
            state = "Climbing"
        elseif humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            state = "Jumping"
        elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
            state = "Falling"
        elseif humanoid:GetState() == Enum.HumanoidStateType.Seated then
            state = "Seated"
        elseif humanoid:GetState() == Enum.HumanoidStateType.Swimming then
            state = "Swimming"
        elseif humanoid.MoveDirection.Magnitude > 0 then
            state = "Moving"
        end
        
        local statePosition = self:CalculatePosition(
            self.Settings.StatePosition, 
            boxCorners, 
            headPos, 
            self.Settings.StateXOffset, 
            self.Settings.StateYOffset
        )
        
        playerData.Drawings.State.Position = statePosition
        playerData.Drawings.State.Text = "State: " .. state
        playerData.Drawings.State.Color = color
        playerData.Drawings.State.Transparency = transparency * self.Settings.StateTransparency
        playerData.Drawings.State.Visible = true
    else
        playerData.Drawings.State.Visible = false
    end
else
    playerData.Drawings.State.Visible = false
end

-- Update aim point ESP
if self.Settings.AimPointEnabled then
    local aimPart = FindFirstChild(character, "Head") or FindFirstChild(character, "HumanoidRootPart")
    
    if aimPart then
        local aimPos, onScreen, depth = self:WorldToScreen(aimPart.Position)
        
        if onScreen then
            local aimPointPosition = Vector2new(
                aimPos.X + self.Settings.AimPointXOffset,
                aimPos.Y + self.Settings.AimPointYOffset
            )
            
            local radius = self.Settings.AimPointRadius
            
            if self.Settings.AimPointPulse then
                local pulse = (mathsin(self._pulse * self.Settings.AimPointPulseSpeed) + 1) / 2
                radius = radius * (1 + pulse * (self.Settings.AimPointPulseSize - 1))
            end
            
            playerData.Drawings.AimPoint.Position = aimPointPosition
            playerData.Drawings.AimPoint.Color = color
            playerData.Drawings.AimPoint.Transparency = transparency * self.Settings.AimPointTransparency
            playerData.Drawings.AimPoint.Radius = radius
            playerData.Drawings.AimPoint.Visible = true
            
            if self.Settings.AimPointOutline then
                playerData.Drawings.AimPointOutline.Position = aimPointPosition
                playerData.Drawings.AimPointOutline.Transparency = transparency * self.Settings.AimPointOutlineTransparency
                playerData.Drawings.AimPointOutline.Radius = radius
                playerData.Drawings.AimPointOutline.Visible = true
            else
                playerData.Drawings.AimPointOutline.Visible = false
            end
        else
            playerData.Drawings.AimPoint.Visible = false
            playerData.Drawings.AimPointOutline.Visible = false
        end
    else
        playerData.Drawings.AimPoint.Visible = false
        playerData.Drawings.AimPointOutline.Visible = false
    end
else
    playerData.Drawings.AimPoint.Visible = false
    playerData.Drawings.AimPointOutline.Visible = false
end

-- Update skeleton ESP
if self.Settings.SkeletonEnabled then
    local skeletonPoints = self:GetSkeletonPoints(character)
    
    -- Clear any existing dashed skeleton lines
    for _, line in pairs(playerData.Drawings.SkeletonDashed) do
        self:RemoveDrawing(line)
    end
    playerData.Drawings.SkeletonDashed = {}
    
    if skeletonPoints then
        if self.Settings.SkeletonStyle == "Line" then
            for i, points in ipairs(skeletonPoints) do
                if i <= #playerData.Drawings.Skeleton then
                    playerData.Drawings.Skeleton[i].Line.From = points[1]
                    playerData.Drawings.Skeleton[i].Line.To = points[2]
                    playerData.Drawings.Skeleton[i].Line.Color = color
                    playerData.Drawings.Skeleton[i].Line.Transparency = transparency * self.Settings.SkeletonTransparency
                    playerData.Drawings.Skeleton[i].Line.Visible = true
                    
                    if self.Settings.SkeletonOutline then
                        playerData.Drawings.Skeleton[i].Outline.From = points[1]
                        playerData.Drawings.Skeleton[i].Outline.To = points[2]
                        playerData.Drawings.Skeleton[i].Outline.Transparency = transparency * self.Settings.SkeletonOutlineTransparency
                        playerData.Drawings.Skeleton[i].Outline.Visible = true
                    else
                        playerData.Drawings.Skeleton[i].Outline.Visible = false
                    end
                end
            end
            
            -- Hide unused skeleton lines
            for i = #skeletonPoints + 1, #playerData.Drawings.Skeleton do
                playerData.Drawings.Skeleton[i].Line.Visible = false
                playerData.Drawings.Skeleton[i].Outline.Visible = false
            end
        elseif self.Settings.SkeletonStyle == "Dashed" or self.Settings.SkeletonStyle == "Dotted" then
            -- Hide regular skeleton lines
            for i = 1, #playerData.Drawings.Skeleton do
                playerData.Drawings.Skeleton[i].Line.Visible = false
                playerData.Drawings.Skeleton[i].Outline.Visible = false
            end
            
            local dashSize = self.Settings.SkeletonStyle == "Dotted" and 1 or self.Settings.SkeletonDashSize
            local gapSize = self.Settings.SkeletonDashGap
            
            for _, points in ipairs(skeletonPoints) do
                local dashedLines = self:DrawDashedLine(
                    points[1], 
                    points[2], 
                    dashSize, 
                    gapSize, 
                    color, 
                    self.Settings.SkeletonThickness, 
                    transparency * self.Settings.SkeletonTransparency, 
                    self.Settings.ZIndex
                )
                
                for _, line in ipairs(dashedLines) do
                    tableinsert(playerData.Drawings.SkeletonDashed, line)
                end
            end
        end
    else
        for i = 1, #playerData.Drawings.Skeleton do
            playerData.Drawings.Skeleton[i].Line.Visible = false
            playerData.Drawings.Skeleton[i].Outline.Visible = false
        end
    end
else
    for i = 1, #playerData.Drawings.Skeleton do
        playerData.Drawings.Skeleton[i].Line.Visible = false
        playerData.Drawings.Skeleton[i].Outline.Visible = false
    end
    
    for _, line in pairs(playerData.Drawings.SkeletonDashed) do
        line.Visible = false
    end
end

-- Update hitbox ESP
if self.Settings.HitboxEnabled then
    local hitboxPoints = self:GetHitboxPoints(character)
    
    if hitboxPoints then
        for i, point in ipairs(hitboxPoints) do
            if i <= #playerData.Drawings.Hitbox then
                playerData.Drawings.Hitbox[i].Position = point
                playerData.Drawings.Hitbox[i].Color = color
                playerData.Drawings.Hitbox[i].Transparency = transparency * self.Settings.HitboxTransparency
                playerData.Drawings.Hitbox[i].Visible = true
            end
        end
        
        -- Hide unused hitbox points
        for i = #hitboxPoints + 1, #playerData.Drawings.Hitbox do
            playerData.Drawings.Hitbox[i].Visible = false
        end
    else
        for i = 1, #playerData.Drawings.Hitbox do
            playerData.Drawings.Hitbox[i].Visible = false
        end
    end
else
    for i = 1, #playerData.Drawings.Hitbox do
        playerData.Drawings.Hitbox[i].Visible = false
    end
end
end

-- Object ESP Functions
function ESP:CreateObjectESP(object, customSettings)
if not object then return end

local objectId = tostring(object:GetFullName())

-- Create default settings for the object
local settings = {}
for key, value in pairs(self.Settings) do
    settings[key] = value
end

-- Apply custom settings if provided
if customSettings then
    for key, value in pairs(customSettings) do
        settings[key] = value
    end
end

local objectData = {
    Object = object,
    Settings = settings,
    Drawings = {
        Box = self:CreateDrawing("Square", {
            Visible = false,
            Color = settings.BoxColor,
            Thickness = settings.BoxThickness,
            Transparency = settings.BoxTransparency,
            Filled = settings.BoxFilled,
            ZIndex = settings.ZIndex
        }),
        BoxOutline = self:CreateDrawing("Square", {
            Visible = false,
            Color = settings.BoxOutlineColor,
            Thickness = settings.BoxThickness + 2,
            Transparency = settings.BoxOutlineTransparency,
            Filled = false,
            ZIndex = settings.ZIndex - 1
        }),
        BoxFill = self:CreateDrawing("Square", {
            Visible = false,
            Color = settings.BoxColor,
            Transparency = settings.BoxFilledTransparency,
            Filled = true,
            ZIndex = settings.ZIndex - 2
        }),
        BoxCorners = {},
        Box3D = {},
        Name = self:CreateDrawing("Text", {
            Visible = false,
            Color = settings.NameColor,
            Transparency = settings.NameTransparency,
            Size = settings.NameSize,
            Center = true,
            Outline = settings.NameOutline,
            OutlineColor = settings.NameOutlineColor,
            Font = settings.NameFont,
            ZIndex = settings.ZIndex
        }),
        Distance = self:CreateDrawing("Text", {
            Visible = false,
            Color = settings.DistanceColor,
            Transparency = settings.DistanceTransparency,
            Size = settings.DistanceSize,
            Center = true,
            Outline = settings.DistanceOutline,
            OutlineColor = settings.DistanceOutlineColor,
            Font = settings.DistanceFont,
            ZIndex = settings.ZIndex
        }),
        Tracer = self:CreateDrawing("Line", {
            Visible = false,
            Color = settings.TracerColor,
            Thickness = settings.TracerThickness,
            Transparency = settings.TracerTransparency,
            ZIndex = settings.ZIndex
        }),
        TracerOutline = self:CreateDrawing("Line", {
            Visible = false,
            Color = settings.TracerOutlineColor,
            Thickness = settings.TracerThickness + 2,
            Transparency = settings.TracerOutlineTransparency,
            ZIndex = settings.ZIndex - 1
        }),
        TracerDashed = {}
    }
}

-- Create corner box lines
for i = 1, 8 do
    objectData.Drawings.BoxCorners[i] = {
        Line = self:CreateDrawing("Line", {
            Visible = false,
            Color = settings.BoxColor,
            Thickness = settings.BoxThickness,
            Transparency = settings.BoxTransparency,
            ZIndex = settings.ZIndex
        }),
        Outline = self:CreateDrawing("Line", {
            Visible = false,
            Color = settings.BoxOutlineColor,
            Thickness = settings.BoxThickness + 2,
            Transparency = settings.BoxOutlineTransparency,
            ZIndex = settings.ZIndex - 1
        })
    }
end

-- Create 3D box lines
for i = 1, 12 do
    objectData.Drawings.Box3D[i] = {
        Line = self:CreateDrawing("Line", {
            Visible = false,
            Color = settings.BoxColor,
            Thickness = settings.BoxThickness,
            Transparency = settings.BoxTransparency,
            ZIndex = settings.ZIndex
        }),
        Outline = self:CreateDrawing("Line", {
            Visible = false,
            Color = settings.BoxOutlineColor,
            Thickness = settings.BoxThickness + 2,
            Transparency = settings.BoxOutlineTransparency,
            ZIndex = settings.ZIndex - 1
        })
    }
end

self.Objects[objectId] = objectData
return objectData
end

function ESP:RemoveObjectESP(object)
local objectId = tostring(object:GetFullName())
local objectData = self.Objects[objectId]

if objectData then
    for _, drawing in pairs(objectData.Drawings) do
        if type(drawing) == "table" then
            if drawing.Line then
                self:RemoveDrawing(drawing.Line)
                self:RemoveDrawing(drawing.Outline)
            else
                for _, subDrawing in pairs(drawing) do
                    if type(subDrawing) == "table" then
                        self:RemoveDrawing(subDrawing.Line)
                        self:RemoveDrawing(subDrawing.Outline)
                    else
                        self:RemoveDrawing(subDrawing)
                    end
                end
            end
        else
            self:RemoveDrawing(drawing)
        end
    end
    
    self.Objects[objectId] = nil
end
end

function ESP:UpdateObjectESP(object)
local objectId = tostring(object:GetFullName())
local objectData = self.Objects[objectId]

if not objectData then return end

-- Get object position
local position
if object:IsA("Model") then
    local primaryPart = object.PrimaryPart or object:FindFirstChildWhichIsA("BasePart")
    if not primaryPart then return end
    position = primaryPart.Position
elseif object:IsA("BasePart") then
    position = object.Position
else
    return
end

-- Check distance
local distance = self:GetDistance(position)
if distance > objectData.Settings.MaxDistance then
    for _, drawing in pairs(objectData.Drawings) do
        if type(drawing) == "table" then
            if drawing.Line then
                drawing.Line.Visible = false
                drawing.Outline.Visible = false
            else
                for _, subDrawing in pairs(drawing) do
                    if type(subDrawing) == "table" then
                        subDrawing.Line.Visible = false
                        subDrawing.Outline.Visible = false
                    else
                        subDrawing.Visible = false
                    end
                end
            end
        else
            drawing.Visible = false
        end
    end
    return
end

-- Calculate transparency based on distance
local transparency = self:CalculateTransparency(distance)

-- Update box ESP
if objectData.Settings.BoxEnabled then
    local boxCorners = self:GetBoxCorners(object)
    
    -- Hide all box types first
    objectData.Drawings.Box.Visible = false
    objectData.Drawings.BoxOutline.Visible = false
    objectData.Drawings.BoxFill.Visible = false
    
    for _, corner in pairs(objectData.Drawings.BoxCorners) do
        corner.Line.Visible = false
        corner.Outline.Visible = false
    end
    
    for _, line in pairs(objectData.Drawings.Box3D) do
        line.Line.Visible = false
        line.Outline.Visible = false
    end
    
    if boxCorners then
        local topLeft = boxCorners.TopLeft
        local bottomRight = boxCorners.BottomRight
        local boxSize = bottomRight - topLeft
        
        if objectData.Settings.BoxType == "2D" then
            objectData.Drawings.Box.Position = topLeft
            objectData.Drawings.Box.Size = boxSize
            objectData.Drawings.Box.Color = objectData.Settings.BoxColor
            objectData.Drawings.Box.Transparency = transparency * objectData.Settings.BoxTransparency
            objectData.Drawings.Box.Visible = true
            
            if objectData.Settings.BoxOutline then
                objectData.Drawings.BoxOutline.Position = topLeft
                objectData.Drawings.BoxOutline.Size = boxSize
                objectData.Drawings.BoxOutline.Transparency = transparency * objectData.Settings.BoxOutlineTransparency
                objectData.Drawings.BoxOutline.Visible = true
            end
            
            if objectData.Settings.BoxFilled then
                objectData.Drawings.BoxFill.Position = topLeft
                objectData.Drawings.BoxFill.Size = boxSize
                objectData.Drawings.BoxFill.Color = objectData.Settings.BoxColor
                objectData.Drawings.BoxFill.Transparency = transparency * objectData.Settings.BoxFilledTransparency
                objectData.Drawings.BoxFill.Visible = true
            end
        elseif objectData.Settings.BoxType == "Corner" then
            local cornerPoints = self:GetCornerBoxPoints(boxCorners)
            
            if cornerPoints then
                for i, points in ipairs(cornerPoints) do
                    if i <= #objectData.Drawings.BoxCorners then
                        objectData.Drawings.BoxCorners[i].Line.From = points[1]
                        objectData.Drawings.BoxCorners[i].Line.To = points[2]
                        objectData.Drawings.BoxCorners[i].Line.Color = objectData.Settings.BoxColor
                        objectData.Drawings.BoxCorners[i].Line.Transparency = transparency * objectData.Settings.BoxTransparency
                        objectData.Drawings.BoxCorners[i].Line.Visible = true
                        
                        if objectData.Settings.BoxOutline then
                            objectData.Drawings.BoxCorners[i].Outline.From = points[1]
                            objectData.Drawings.BoxCorners[i].Outline.To = points[2]
                            objectData.Drawings.BoxCorners[i].Outline.Transparency = transparency * objectData.Settings.BoxOutlineTransparency
                            objectData.Drawings.BoxCorners[i].Outline.Visible = true
                        end
                    end
                end
            end
        elseif objectData.Settings.BoxType == "3D" then
            local corners3D = self:Get3DBoxCorners(object)
            
            if corners3D then
                -- Define the 12 edges of a 3D box
                local edges = {
                    -- Top square
                    {1, 2}, {2, 4}, {4, 3}, {3, 1},
                    -- Bottom square
                    {5, 6}, {6, 8}, {8, 7}, {7, 5},
                    -- Connecting lines
                    {1, 5}, {2, 6}, {3, 7}, {4, 8}
                }
                
                for i, edge in ipairs(edges) do
                    if i <= #objectData.Drawings.Box3D then
                        objectData.Drawings.Box3D[i].Line.From = corners3D[edge[1]]
                        objectData.Drawings.Box3D[i].Line.To = corners3D[edge[2]]
                        objectData.Drawings.Box3D[i].Line.Color = objectData.Settings.BoxColor
                        objectData.Drawings.Box3D[i].Line.Transparency = transparency * objectData.Settings.BoxTransparency
                        objectData.Drawings.Box3D[i].Line.Visible = true
                        
                        if objectData.Settings.BoxOutline then
                            objectData.Drawings.Box3D[i].Outline.From = corners3D[edge[1]]
                            objectData.Drawings.Box3D[i].Outline.To = corners3D[edge[2]]
                            objectData.Drawings.Box3D[i].Outline.Transparency = transparency * objectData.Settings.BoxOutlineTransparency
                            objectData.Drawings.Box3D[i].Outline.Visible = true
                        end
                    end
                end
            end
        end
    end
else
    objectData.Drawings.Box.Visible = false
    objectData.Drawings.BoxOutline.Visible = false
    objectData.Drawings.BoxFill.Visible = false
    
    for _, corner in pairs(objectData.Drawings.BoxCorners) do
        corner.Line.Visible = false
        corner.Outline.Visible = false
    end
    
    for _, line in pairs(objectData.Drawings.Box3D) do
        line.Line.Visible = false
        line.Outline.Visible = false
    end
end

-- Update name ESP
if objectData.Settings.NameEnabled then
    local screenPos, onScreen, depth = self:WorldToScreen(position)
    local boxCorners = self:GetBoxCorners(object)
    
    if onScreen then
        local displayName = object.Name
        local textSize = self:CalculateTextSize(distance)
        local namePosition = self:CalculatePosition(
            objectData.Settings.NamePosition, 
            boxCorners, 
            screenPos, 
            objectData.Settings.NameXOffset, 
            objectData.Settings.NameYOffset
        )
        
        objectData.Drawings.Name.Position = namePosition
        objectData.Drawings.Name.Text = displayName
        objectData.Drawings.Name.Transparency = transparency * objectData.Settings.NameTransparency
        objectData.Drawings.Name.Size = textSize
        objectData.Drawings.Name.Visible = true
    else
        objectData.Drawings.Name.Visible = false
    end
else
    objectData.Drawings.Name.Visible = false
end

-- Update distance ESP
if objectData.Settings.DistanceEnabled then
    local screenPos, onScreen, depth = self:WorldToScreen(position)
    local boxCorners = self:GetBoxCorners(object)
    
    if onScreen then
        local distanceText = self:GetDistanceText(distance)
        local textSize = self:CalculateTextSize(distance)
        local distancePosition = self:CalculatePosition(
            objectData.Settings.DistancePosition, 
            boxCorners, 
            screenPos, 
            objectData.Settings.DistanceXOffset, 
            objectData.Settings.DistanceYOffset
        )
        
        objectData.Drawings.Distance.Position = distancePosition
        objectData.Drawings.Distance.Text = distanceText
        objectData.Drawings.Distance.Transparency = transparency * objectData.Settings.DistanceTransparency
        objectData.Drawings.Distance.Size = textSize
        objectData.Drawings.Distance.Visible = true
    else
        objectData.Drawings.Distance.Visible = false
    end
else
    objectData.Drawings.Distance.Visible = false
end

-- Update tracer ESP
if objectData.Settings.TracerEnabled then
    local screenPos, onScreen, depth = self:WorldToScreen(position)
    
    if onScreen then
        local from
        
        if objectData.Settings.TracerOrigin == "Bottom" then
            from = Vector2new(Camera.ViewportSize.X / 2 + objectData.Settings.TracerXOffset, Camera.ViewportSize.Y + objectData.Settings.TracerYOffset)
        elseif objectData.Settings.TracerOrigin == "Center" then
            from = Vector2new(Camera.ViewportSize.X / 2 + objectData.Settings.TracerXOffset, Camera.ViewportSize.Y / 2 + objectData.Settings.TracerYOffset)
        elseif objectData.Settings.TracerOrigin == "Mouse" then
            from = UserInputService:GetMouseLocation() + Vector2new(objectData.Settings.TracerXOffset, objectData.Settings.TracerYOffset)
        end
        
        -- Clear any existing dashed tracers
        for _, line in pairs(objectData.Drawings.TracerDashed) do
            self:RemoveDrawing(line)
        end
        objectData.Drawings.TracerDashed = {}
        
        if objectData.Settings.TracerStyle == "Line" then
            objectData.Drawings.Tracer.From = from
            objectData.Drawings.Tracer.To = screenPos
            objectData.Drawings.Tracer.Color = objectData.Settings.TracerColor
            objectData.Drawings.Tracer.Transparency = transparency * objectData.Settings.TracerTransparency
            objectData.Drawings.Tracer.Visible = true
            
            if objectData.Settings.TracerOutline then
                objectData.Drawings.TracerOutline.From = from
                objectData.Drawings.TracerOutline.To = screenPos
                objectData.Drawings.TracerOutline.Transparency = transparency * objectData.Settings.TracerOutlineTransparency
                objectData.Drawings.TracerOutline.Visible = true
            else
                objectData.Drawings.TracerOutline.Visible = false
            end
        elseif objectData.Settings.TracerStyle == "Dashed" or objectData.Settings.TracerStyle == "Dotted" then
            objectData.Drawings.Tracer.Visible = false
            objectData.Drawings.TracerOutline.Visible = false
            
            local dashSize = objectData.Settings.TracerStyle == "Dotted" and 1 or objectData.Settings.TracerDashSize
            local gapSize = objectData.Settings.TracerDashGap
            
            objectData.Drawings.TracerDashed = self:DrawDashedLine(
                from, 
                screenPos, 
                dashSize, 
                gapSize, 
                objectData.Settings.TracerColor, 
                objectData.Settings.TracerThickness, 
                transparency * objectData.Settings.TracerTransparency, 
                objectData.Settings.ZIndex
            )
        end
    else
        objectData.Drawings.Tracer.Visible = false
        objectData.Drawings.TracerOutline.Visible = false
        
        for _, line in pairs(objectData.Drawings.TracerDashed) do
            line.Visible = false
        end
    end
else
    objectData.Drawings.Tracer.Visible = false
    objectData.Drawings.TracerOutline.Visible = false
    
    for _, line in pairs(objectData.Drawings.TracerDashed) do
        line.Visible = false
    end
end
end

-- Main Functions
function ESP:Init()
-- Create connections
self.Connections.PlayerAdded = Players.PlayerAdded:Connect(function(player)
    self:CreatePlayerESP(player)
end)

self.Connections.PlayerRemoving = Players.PlayerRemoving:Connect(function(player)
    self:RemovePlayerESP(player)
end)

self.Connections.RenderStepped = RunService.RenderStepped:Connect(function()
    if not self.Enabled then return end
    
    -- Update rainbow color and pulse
    if self.Settings.RainbowMode then
        self._rainbow = (self._rainbow + self.Settings.RainbowSpeed * 0.01) % 1
    end
    
    self._pulse = (self._pulse + 0.05) % (mathpi * 2)
    
    -- Update player ESP
    for player, playerData in pairs(self.Players) do
        self:UpdatePlayerESP(player)
    end
    
    -- Update object ESP
    for objectId, objectData in pairs(self.Objects) do
        if objectData.Object and objectData.Object.Parent then
            self:UpdateObjectESP(objectData.Object)
        else
            self:RemoveObjectESP(objectData.Object)
        end
    end
end)

self.Connections.InputBegan = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == self.Settings.ToggleKey then
        self.Enabled = not self.Enabled
        
        if not self.Enabled then
            for _, playerData in pairs(self.Players) do
                for _, drawing in pairs(playerData.Drawings) do
                    if type(drawing) == "table" then
                        if drawing.Line then
                            drawing.Line.Visible = false
                            drawing.Outline.Visible = false
                        else
                            for _, subDrawing in pairs(drawing) do
                                if type(subDrawing) == "table" then
                                    subDrawing.Line.Visible = false
                                    subDrawing.Outline.Visible = false
                                else
                                    subDrawing.Visible = false
                                end
                            end
                        end
                    else
                        drawing.Visible = false
                    end
                end
            end
            
            for _, objectData in pairs(self.Objects) do
                for _, drawing in pairs(objectData.Drawings) do
                    if type(drawing) == "table" then
                        if drawing.Line then
                            drawing.Line.Visible = false
                            drawing.Outline.Visible = false
                        else
                            for _, subDrawing in pairs(drawing) do
                                if type(subDrawing) == "table" then
                                    subDrawing.Line.Visible = false
                                    subDrawing.Outline.Visible = false
                                else
                                    subDrawing.Visible = false
                                end
                            end
                        end
                    else
                        drawing.Visible = false
                    end
                end
            end
        end
    elseif input.KeyCode == self.Settings.BoxToggleKey then
        self.Settings.BoxEnabled = not self.Settings.BoxEnabled
    elseif input.KeyCode == self.Settings.NameToggleKey then
        self.Settings.NameEnabled = not self.Settings.NameEnabled
    elseif input.KeyCode == self.Settings.DistanceToggleKey then
        self.Settings.DistanceEnabled = not self.Settings.DistanceEnabled
    elseif input.KeyCode == self.Settings.HealthToggleKey then
        self.Settings.HealthEnabled = not self.Settings.HealthEnabled
    elseif input.KeyCode == self.Settings.TracerToggleKey then
        self.Settings.TracerEnabled = not self.Settings.TracerEnabled
    elseif input.KeyCode == self.Settings.ChamsToggleKey then
        self.Settings.ChamsEnabled = not self.Settings.ChamsEnabled
    elseif input.KeyCode == self.Settings.SkeletonToggleKey then
        self.Settings.SkeletonEnabled = not self.Settings.SkeletonEnabled
    elseif input.KeyCode == self.Settings.HeadDotToggleKey then
        self.Settings.HeadDotEnabled = not self.Settings.HeadDotEnabled
    end
end)

-- Initialize existing players
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        self:CreatePlayerESP(player)
    end
end

return self
end

function ESP:Destroy()
-- Disconnect all connections
for _, connection in pairs(self.Connections) do
    connection:Disconnect()
end

-- Remove all drawings
self:ClearDrawings()

-- Clear tables
self.Connections = {}
self.Players = {}
self.Objects = {}
self._transitions = {}
end

-- API Functions
function ESP:Toggle(enabled)
if enabled ~= nil then
    self.Enabled = enabled
else
    self.Enabled = not self.Enabled
end

return self.Enabled
end

function ESP:ToggleBox(enabled)
if enabled ~= nil then
    self.Settings.BoxEnabled = enabled
else
    self.Settings.BoxEnabled = not self.Settings.BoxEnabled
end

return self.Settings.BoxEnabled
end

function ESP:SetBoxType(boxType)
self.Settings.BoxType = boxType
return boxType
end

function ESP:ToggleName(enabled)
if enabled ~= nil then
    self.Settings.NameEnabled = enabled
else
    self.Settings.NameEnabled = not self.Settings.NameEnabled
end

return self.Settings.NameEnabled
end

function ESP:ToggleDistance(enabled)
if enabled ~= nil then
    self.Settings.DistanceEnabled = enabled
else
    self.Settings.DistanceEnabled = not self.Settings.DistanceEnabled
end

return self.Settings.DistanceEnabled
end

function ESP:ToggleHealth(enabled)
if enabled ~= nil then
    self.Settings.HealthEnabled = enabled
else
    self.Settings.HealthEnabled = not self.Settings.HealthEnabled
end

return self.Settings.HealthEnabled
end

function ESP:ToggleTracer(enabled)
if enabled ~= nil then
    self.Settings.TracerEnabled = enabled
else
    self.Settings.TracerEnabled = not self.Settings.TracerEnabled
end

return self.Settings.TracerEnabled
end

function ESP:ToggleChams(enabled)
if enabled ~= nil then
    self.Settings.ChamsEnabled = enabled
else
    self.Settings.ChamsEnabled = not self.Settings.ChamsEnabled
end

return self.Settings.ChamsEnabled
end

function ESP:ToggleSkeleton(enabled)
if enabled ~= nil then
    self.Settings.SkeletonEnabled = enabled
else
    self.Settings.SkeletonEnabled = not self.Settings.SkeletonEnabled
end

return self.Settings.SkeletonEnabled
end

function ESP:ToggleHeadDot(enabled)
if enabled ~= nil then
    self.Settings.HeadDotEnabled = enabled
else
    self.Settings.HeadDotEnabled = not self.Settings.HeadDotEnabled
end

return self.Settings.HeadDotEnabled
end

function ESP:ToggleTeamCheck(enabled)
if enabled ~= nil then
    self.Settings.TeamCheck = enabled
else
    self.Settings.TeamCheck = not self.Settings.TeamCheck
end

return self.Settings.TeamCheck
end

function ESP:ToggleVisibilityCheck(enabled)
if enabled ~= nil then
    self.Settings.VisibilityCheck = enabled
else
    self.Settings.VisibilityCheck = not self.Settings.VisibilityCheck
end

return self.Settings.VisibilityCheck
end

function ESP:SetColor(color)
self.Settings.BoxColor = color
self.Settings.NameColor = color
self.Settings.DistanceColor = color
self.Settings.TracerColor = color
self.Settings.SkeletonColor = color

return color
end

function ESP:SetTeamColor(color)
self.Settings.TeamColor = color

return color
end

function ESP:SetEnemyColor(color)
self.Settings.EnemyColor = color

return color
end

function ESP:SetMaxDistance(distance)
self.Settings.MaxDistance = distance

return distance
end

function ESP:AddToWhitelist(player)
if type(player) == "string" then
    tableinsert(self.Settings.Whitelist, player)
elseif type(player) == "number" then
    tableinsert(self.Settings.Whitelist, player)
elseif player:IsA("Player") then
    tableinsert(self.Settings.Whitelist, player.Name)
end

return self.Settings.Whitelist
end

function ESP:RemoveFromWhitelist(player)
if type(player) == "string" then
    for i, name in ipairs(self.Settings.Whitelist) do
        if name == player then
            tableremove(self.Settings.Whitelist, i)
            break
        end
    end
elseif type(player) == "number" then
    for i, id in ipairs(self.Settings.Whitelist) do
        if id == player then
            tableremove(self.Settings.Whitelist, i)
            break
        end
    end
elseif player:IsA("Player") then
    for i, name in ipairs(self.Settings.Whitelist) do
        if name == player.Name then
            tableremove(self.Settings.Whitelist, i)
            break
        end
    end
end

return self.Settings.Whitelist
end

function ESP:AddToBlacklist(player)
if type(player) == "string" then
    tableinsert(self.Settings.Blacklist, player)
elseif type(player) == "number" then
    tableinsert(self.Settings.Blacklist, player)
elseif player:IsA("Player") then
    tableinsert(self.Settings.Blacklist, player.Name)
end

return self.Settings.Blacklist
end

function ESP:RemoveFromBlacklist(player)
if type(player) == "string" then
    for i, name in ipairs(self.Settings.Blacklist) do
        if name == player then
            tableremove(self.Settings.Blacklist, i)
            break
        end
    end
elseif type(player) == "number" then
    for i, id in ipairs(self.Settings.Blacklist) do
        if id == player then
            tableremove(self.Settings.Blacklist, i)
            break
        end
    end
elseif player:IsA("Player") then
    for i, name in ipairs(self.Settings.Blacklist) do
        if name == player.Name then
            tableremove(self.Settings.Blacklist, i)
            break
        end
    end
end

return self.Settings.Blacklist
end

function ESP:ClearWhitelist()
self.Settings.Whitelist = {}
return self.Settings.Whitelist
end

function ESP:ClearBlacklist()
self.Settings.Blacklist = {}
return self.Settings.Blacklist
end

function ESP:SetRefreshRate(rate)
self.Settings.RefreshRate = rate
return rate
end

function ESP:SetTracerOrigin(origin)
self.Settings.TracerOrigin = origin
return origin
end

function ESP:SetTracerStyle(style)
self.Settings.TracerStyle = style
return style
end

function ESP:SetSkeletonStyle(style)
self.Settings.SkeletonStyle = style
return style
end

function ESP:SetHealthBarType(healthType)
self.Settings.HealthType = healthType
return healthType
end

function ESP:ToggleRainbowMode(enabled)
if enabled ~= nil then
    self.Settings.RainbowMode = enabled
else
    self.Settings.RainbowMode = not self.Settings.RainbowMode
end

return self.Settings.RainbowMode
end

function ESP:SetRainbowSpeed(speed)
self.Settings.RainbowSpeed = speed
return speed
end

function ESP:SetTransparency(transparency)
self.Settings.BoxTransparency = transparency
self.Settings.NameTransparency = transparency
self.Settings.DistanceTransparency = transparency
self.Settings.HealthTransparency = transparency
self.Settings.TracerTransparency = transparency
self.Settings.SkeletonTransparency = transparency
self.Settings.HeadDotTransparency = transparency

return transparency
end

function ESP:SetThickness(thickness)
self.Settings.BoxThickness = thickness
self.Settings.TracerThickness = thickness
self.Settings.SkeletonThickness = thickness
self.Settings.HeadDotThickness = thickness

return thickness
end

-- Position customization functions
function ESP:SetBoxPadding(padding)
if type(padding) == "number" then
    self.Settings.BoxPadding = Vector3new(padding, padding, padding)
else
    self.Settings.BoxPadding = padding
end
return self.Settings.BoxPadding
end

-- Position setting functions
function ESP:SetNamePosition(position, xOffset, yOffset)
self.Settings.NamePosition = position
if xOffset then self.Settings.NameXOffset = xOffset end
if yOffset then self.Settings.NameYOffset = yOffset end
return position
end

function ESP:SetDistancePosition(position, xOffset, yOffset)
self.Settings.DistancePosition = position
if xOffset then self.Settings.DistanceXOffset = xOffset end
if yOffset then self.Settings.DistanceYOffset = yOffset end
return position
end

function ESP:SetHealthPosition(position, xOffset, yOffset)
self.Settings.HealthPosition = position
if xOffset then self.Settings.HealthXOffset = xOffset end
if yOffset then self.Settings.HealthYOffset = yOffset end
return position
end

function ESP:SetToolPosition(position, xOffset, yOffset)
self.Settings.ToolPosition = position
if xOffset then self.Settings.ToolXOffset = xOffset end
if yOffset then self.Settings.ToolYOffset = yOffset end
return position
end

function ESP:SetStatePosition(position, xOffset, yOffset)
self.Settings.StatePosition = position
if xOffset then self.Settings.StateXOffset = xOffset end
if yOffset then self.Settings.StateYOffset = yOffset end
return position
end

function ESP:SetTracerOffset(xOffset, yOffset)
if xOffset then self.Settings.TracerXOffset = xOffset end
if yOffset then self.Settings.TracerYOffset = yOffset end
return Vector2new(self.Settings.TracerXOffset, self.Settings.TracerYOffset)
end

function ESP:SetHeadDotOffset(xOffset, yOffset)
if xOffset then self.Settings.HeadDotXOffset = xOffset end
if yOffset then self.Settings.HeadDotYOffset = yOffset end
return Vector2new(self.Settings.HeadDotXOffset, self.Settings.HeadDotYOffset)
end

function ESP:SetAimPointOffset(xOffset, yOffset)
if xOffset then self.Settings.AimPointXOffset = xOffset end
if yOffset then self.Settings.AimPointYOffset = yOffset end
return Vector2new(self.Settings.AimPointXOffset, self.Settings.AimPointYOffset)
end

-- New API Functions for Direct Object Targeting
function ESP:Add(object, options)
if not object then return end

if object:IsA("Player") then
    local playerData = self:CreatePlayerESP(object)
    return playerData
else
    local objectData = self:CreateObjectESP(object, options)
    return objectData
end
end

function ESP:Remove(object)
if not object then return end

if object:IsA("Player") then
    self:RemovePlayerESP(object)
else
    self:RemoveObjectESP(object)
end
end

function ESP:AddBox(object, options)
local customSettings = options or {}
customSettings.BoxEnabled = true
customSettings.NameEnabled = false
customSettings.DistanceEnabled = false
customSettings.TracerEnabled = false

return self:Add(object, customSettings)
end

function ESP:AddName(object, options)
local customSettings = options or {}
customSettings.BoxEnabled = false
customSettings.NameEnabled = true
customSettings.DistanceEnabled = false
customSettings.TracerEnabled = false

return self:Add(object, customSettings)
end

function ESP:AddDistance(object, options)
local customSettings = options or {}
customSettings.BoxEnabled = false
customSettings.NameEnabled = false
customSettings.DistanceEnabled = true
customSettings.TracerEnabled = false

return self:Add(object, customSettings)
end

function ESP:AddTracer(object, options)
local customSettings = options or {}
customSettings.BoxEnabled = false
customSettings.NameEnabled = false
customSettings.DistanceEnabled = false
customSettings.TracerEnabled = true

return self:Add(object, customSettings)
end

function ESP:AddFull(object, options)
local customSettings = options or {}
customSettings.BoxEnabled = true
customSettings.NameEnabled = true
customSettings.DistanceEnabled = true
customSettings.TracerEnabled = true

return self:Add(object, customSettings)
end

-- Create and return the ESP instance
local espLib = ESP:Init()

-- Return the ESP library
return espLib
